// Generated by CoffeeScript 1.10.0
(function() {
  var BUILD_MODES, DEBUG, DEFAULT_ATTR_VALUES, ERROR_MESSAGE_CONFIG, ERROR_MODES, ERROR_OUTPUT_MODES, FormModifier, OPTIONAL_CACHE, REQUIRED_CACHE, VALIDATION_PHASES, VALIDATION_PHASES_SINGULAR, build_mode_helpers, constraint_validator_groups, constraint_validator_options, constraint_validator_options_in_locale_key, constraint_validators, default_message_builder, error_message_builders, get_combined_key, get_permutations, get_subsets, group_arr_by, include_constraint_option_in_locale_key, locale_build_mode_helpers, locales, parse_deps, part_evaluator, permutation_cache, set, set_add, set_remove, toposort, validators,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  DEBUG = true;

  if (Array.prototype.unique == null) {
    Array.prototype.unique = function() {
      var elem, l, len, res;
      res = [];
      for (l = 0, len = this.length; l < len; l++) {
        elem = this[l];
        if (indexOf.call(res, elem) < 0) {
          res.push(elem);
        }
      }
      return res;
    };
  }

  if ($.fn.attrAll == null) {
    $.fn.attrAll = function(propName, delimiter, unique) {
      var result;
      if (delimiter == null) {
        delimiter = " ";
      }
      if (unique == null) {
        unique = true;
      }
      result = [];
      this.each(function(idx, elem) {
        result.push($(elem).attr(propName));
        return true;
      });
      if (unique) {
        result = result.unique();
      }
      return result.join(delimiter);
    };
  }

  get_permutations = function(arr) {
    var permute, results;
    permute = function(arr, memo) {
      var cur, i, l, ref, results1;
      if (memo == null) {
        memo = [];
      }
      results1 = [];
      for (i = l = 0, ref = arr.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        cur = arr.splice(i, 1);
        if (arr.length === 0) {
          results.push(memo.concat(cur));
        }
        permute(arr.slice(), memo.concat(cur));
        results1.push(arr.splice(i, 0, cur[0]));
      }
      return results1;
    };
    results = [];
    permute(arr);
    return results;
  };

  get_subsets = function(set, k) {
    var i, index, j, n, p, r, subsets;
    subsets = [];
    n = set.length;
    p = (function() {
      var l, ref, results1;
      results1 = [];
      for (i = l = 0, ref = k; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results1.push(i);
      }
      return results1;
    })();
    while (true) {
      subsets.push((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = p.length; l < len; l++) {
          index = p[l];
          results1.push(set[index]);
        }
        return results1;
      })());
      if (p[0] === n - k) {
        break;
      }
      i = k - 1;
      while (i >= 0 && p[i] + k - i === n) {
        i--;
      }
      r = p[i];
      p[i]++;
      j = 2;
      i++;
      while (i < k) {
        p[i] = r + j;
        i++;
        j++;
      }
    }
    return subsets;
  };

  group_arr_by = function(arr, get_prop) {
    var elem, grouped, key, l, len;
    grouped = {};
    for (l = 0, len = arr.length; l < len; l++) {
      elem = arr[l];
      if ((key = typeof get_prop === "function" ? get_prop(elem) : void 0) == null) {
        key = elem;
      }
      if (grouped[key] == null) {
        grouped[key] = [];
      }
      grouped[key].push(elem);
    }
    return grouped;
  };

  toposort = function(targets) {
    var independents, k, l, len, parent, ref, result, reverse_deps;
    targets = parse_deps(targets);
    independents = [];
    (function() {
      var k, results1;
      results1 = [];
      for (k in targets) {
        if (targets[k].cnt === 0) {
          delete targets[k];
          results1.push(independents.push(k));
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    })();
    reverse_deps = [];
    (function() {
      var child, k, results1;
      results1 = [];
      for (k in targets) {
        results1.push((function() {
          var results2;
          results2 = [];
          for (child in targets[k].v) {
            if (reverse_deps[child] == null) {
              reverse_deps[child] = [];
            }
            results2.push(reverse_deps[child].push(k));
          }
          return results2;
        })());
      }
      return results1;
    })();
    result = [];
    while (independents.length > 0) {
      k = independents.pop();
      result.push(k);
      ref = reverse_deps[k] || [];
      for (l = 0, len = ref.length; l < len; l++) {
        parent = ref[l];
        set_remove(targets[parent], k);
        if (targets[parent].cnt === 0) {
          independents.push(parent);
          delete targets[parent];
        }
      }
    }
    for (k in targets) {
      throw new Error("FormValidator::validate: Detected cyclical dependencies. Adjust your dependency definitions");
    }
    return result;
  };

  parse_deps = function(data) {
    var child, children, dep, deps, k, l, len, targets, v;
    targets = {};
    deps = set();
    for (k in data) {
      v = data[k];
      targets[k] = set();
      children = v.split(' ');
      for (l = 0, len = children.length; l < len; l++) {
        child = children[l];
        if (child === '') {
          continue;
        }
        if (child !== k) {
          set_add(targets[k], child);
        }
        set_add(deps, child);
      }
    }
    for (dep in deps.v) {
      if (!(dep in targets)) {
        targets[dep] = set();
      }
    }
    return targets;
  };

  set = function() {
    return {
      cnt: 0,
      v: {}
    };
  };

  set_add = function(s, e) {
    if (!s.v[e]) {
      s.cnt += 1;
      s.v[e] = true;
    }
    return s;
  };

  set_remove = function(s, e) {
    if (s.v[e]) {
      s.cnt -= 1;
      delete s.v[e];
    }
    return s;
  };

  ERROR_MODES = {
    NORMAL: "NORMAL",
    SIMPLE: "SIMPLE"
  };

  ERROR_MODES.DEFAULT = ERROR_MODES.NORMAL;

  ERROR_OUTPUT_MODES = {
    BELOW: "BELOW",
    TOOLTIP: "TOOLTIP",
    POPOVER: "POPOVER",
    NONE: "NONE"
  };

  ERROR_OUTPUT_MODES.DEFAULT = ERROR_OUTPUT_MODES.NONE;

  VALIDATION_PHASES = {
    DEPENDENCIES: "DEPENDENCIES",
    VALUE: "VALUE",
    CONSTRAINTS: "CONSTRAINTS"
  };

  VALIDATION_PHASES_SINGULAR = {
    DEPENDENCIES: "DEPENDENCY",
    VALUE: "VALUE",
    CONSTRAINTS: "CONSTRAINT"
  };

  BUILD_MODES = {
    ENUMERATE: "ENUMERATE",
    SENTENCE: "SENTENCE",
    LIST: "LIST"
  };

  BUILD_MODES.DEFAULT = BUILD_MODES.ENUMERATE;

  ERROR_MESSAGE_CONFIG = {
    PHASE_ORDER: [VALIDATION_PHASES.DEPENDENCIES, VALIDATION_PHASES.VALUE, VALIDATION_PHASES.CONSTRAINTS],
    BUILD_MODE: BUILD_MODES.DEFAULT
  };

  REQUIRED_CACHE = ["depends_on", "id", "name", "preprocess", "required", "type"];

  OPTIONAL_CACHE = ["dependency_mode", "error_classes", "dependency_error_classes", "error_targets", "group", "output_preprocessed", "postprocess", "constraints", "errors", "valid_constraints", "valid_dependencies", "valid_value", "value"];

  DEFAULT_ATTR_VALUES = {
    PREPROCESS: true,
    POSTPROCESS: false,
    REQUIRED: true,
    OUTPUT_PREPROCESSED: true,
    DEPENDENCY_MODE: "all",
    ERROR_TARGETS: "",
    INCLUDE_MAX: "true",
    INCLUDE_MIN: "true"
  };

  validators = {
    _number: function(str, elem, min, max, include_min, include_max) {
      var n;
      if (include_min == null) {
        include_min = true;
      }
      if (include_max == null) {
        include_max = true;
      }
      str = str.replace(/\s/g, "");
      if (str[0] === "+") {
        str = str.slice(1);
      }
      if (str[0] === ".") {
        str = "0" + str;
      } else if (str[0] === "-" && str[1] === ".") {
        str = "-0." + (str.slice(2));
      }
      if (str.indexOf(".") >= 0) {
        while (str[str.length - 1] === "0") {
          str = str.slice(0, -1);
        }
        if (str[str.length - 1] === ".") {
          str = str.slice(0, -1);
        }
      }
      n = parseFloat(str);
      if (isNaN(n) || !isFinite(n) || str !== ("" + n)) {
        return {
          error_message_type: "number",
          _number: n,
          _string: str
        };
      }
      return {
        valid: true,
        _number: n,
        _string: str
      };
    },
    _text: function(str, elem, min, max) {
      return str.length > 0;
    },
    email: function(str, elem) {
      var parts;
      if (str.indexOf("@") < 0) {
        return {
          error_message_type: "email_at"
        };
      }
      parts = str.split("@");
      if (parts.length > 2) {
        return {
          error_message_type: "email_many_at"
        };
      }
      if (parts.length === 2 && parts[0] !== "" && parts[1] !== "") {
        if (str.indexOf(".", str.indexOf("@")) < 0 || str[str.length - 1] === ".") {
          return {
            error_message_type: "email_dot"
          };
        }
        return true;
      }
      return {
        error_message_type: "email"
      };
    },
    integer: function(str, elem, min, max, include_min, include_max) {
      var n, res;
      res = this._number(str, elem, min, max, include_min, include_max);
      if (res.valid === true) {
        if (res._number === Math.floor(res._number)) {
          return true;
        }
        return {
          error_message_type: "integer_float"
        };
      }
      str = res._string;
      n = Math.floor(res._number);
      if (isNaN(n) || !isFinite(n) || str !== ("" + n)) {
        return {
          error_message_type: "integer"
        };
      }
      res.error_message_type = res.error_message_type.replace("number_", "integer_");
      return res;
    },
    number: function(str, elem, min, max, include_min, include_max) {
      var res;
      res = this._number(str, elem, min, max, include_min, include_max);
      if (res.valid === true) {
        return true;
      }
      return res;
    },
    phone: function(str, elem) {
      str = str.replace(/[\s+\+\-\/\(\)]/g, "");
      while (str[0] === "0") {
        str = str.slice(1);
      }
      if (str !== ("" + (parseInt(str, 10)))) {
        return {
          error_message_type: "phone"
        };
      }
      return true;
    },
    text: function(str, elem, min, max) {
      return str.length > 0;
    },
    radio: function(str, elem) {
      return $("[name='" + elem.attr("name") + "']:checked").length > 0;
    },
    checkbox: function(str, elem) {
      return elem.prop("checked") === true;
    },
    select: function(str, elem) {
      return this.text(elem.val());
    }
  };

  constraint_validators = {
    blacklist: function(value, blacklist) {
      var char, l, len;
      for (l = 0, len = value.length; l < len; l++) {
        char = value[l];
        if (blacklist.indexOf(char) >= 0) {
          return false;
        }
      }
      return true;
    },
    max: function(value, max, options) {
      if ((options != null ? options.include_max : void 0) === "false") {
        return value < max;
      }
      return value <= max;
    },
    max_length: function(value, max_length) {
      return value.length <= max_length;
    },
    min: function(value, min, options) {
      if ((options != null ? options.include_min : void 0) === "false") {
        return value > min;
      }
      return value >= min;
    },
    min_length: function(value, min_length) {
      return value.length >= min_length;
    },
    regex: function(value, regex, options) {
      return (new RegExp(regex, options.flags)).test(value);
    },
    whitelist: function(value, whitelist) {
      var char, l, len;
      for (l = 0, len = whitelist.length; l < len; l++) {
        char = whitelist[l];
        if (value.indexOf(char) < 0) {
          return false;
        }
      }
      return true;
    }
  };

  constraint_validator_options = {
    max: ["include_max"],
    max_length: ["enforce_max_length"],
    min: ["include_min"],
    min_length: ["enforce_min_length"],
    regex: ["regex_flags"]
  };

  constraint_validator_groups = [];

  constraint_validator_options_in_locale_key = {
    include_max: true,
    include_min: true
  };

  include_constraint_option_in_locale_key = function(option, value) {
    return (value != null) && ("" + constraint_validator_options_in_locale_key[option]) === ("" + value);
  };

  locales = {
    de: {
      and: "und",
      gt: "größer als",
      gte: "größer als oder gleich",
      lt: "kleiner als",
      lte: "kleiner als oder gleich"
    },
    en: {
      and: "and",
      gt: "greater than",
      gte: "greater than or equal to",
      lt: "less than",
      lte: "less than or equal to"
    }
  };

  $.extend(locales.de, {
    dependency_general: "Die Abhängigkeiten dieses Felds müssen zuerst korrekt ausgefüllt wurden",
    dependency_prefix: "Die Felder",
    dependency_suffix: "müssen noch korrekt ausgefüllt werden",
    dependency_singular_prefix: "Das Feld",
    dependency_singular_suffix: "muss noch korrekt ausgefüllt werden",
    value_email: "'{{value}}' muss die Form 'meine.adresse@anbieter.endung' haben",
    value_email_at: "'{{value}}' muss ein @-Zeichen enthalten",
    value_email_many_at: "'{{value}}' darf höchstens ein @-Zeichen enthalten",
    value_email_dot: "'{{value}}' muss eine korrekte Endung haben (z.B. '.de')",
    value_integer: "'{{value}}' muss eine Zahl sein",
    value_integer_float: "'{{value}}' darf keine Kommazahl sein",
    value_number: "'{{value}}' muss eine Zahl sein",
    value_phone: "'{{value}}' darf nur aus Zahlen, Leerzeichen und den Zeichen '+-/()' bestehen",
    value_radio: "Eins der Optionsfelder muss ausgewählt werden",
    value_checkbox: "Das Kontrollkästchen muss ausgewählt werden",
    value_select: "Es muss eine andere Option ausgewählt werden",
    value_text: "Das Textfeld muss ausgefüllt werden",
    constraint_enumerate_prefix: "'{{value}}'",
    constraint_list_prefix: "'{{value}}'",
    constraint_blacklist_prefix: "darf",
    constraint_blacklist: "keines der Zeichen '{{blacklist}}'",
    constraint_blacklist_suffix: "enthalten",
    constraint_whitelist_prefix: "muss",
    constraint_whitelist: "jedes der Zeichen '{{whitelist}}'",
    constraint_whitelist_suffix: "enthalten",
    constraint_max_prefix: "darf",
    constraint_max: "nicht größer als oder gleich {{max}}",
    constraint_max_suffix: "sein",
    constraint_max_include_max_prefix: "darf",
    constraint_max_include_max: "nicht größer als {{max}}",
    constraint_max_include_max_suffix: "sein",
    constraint_max_length_prefix: "darf",
    constraint_max_length: "nicht länger als {{max_length}} Zeichen",
    constraint_max_length_suffix: "sein",
    constraint_min_prefix: "darf",
    constraint_min: "nicht kleiner als oder gleich {{min}}",
    constraint_min_suffix: "sein",
    constraint_min_include_min_prefix: "darf",
    constraint_min_include_min: "nicht kleiner als {{min}}",
    constraint_min_include_min_suffix: "sein",
    constraint_min_length_prefix: "darf",
    constraint_min_length: "nicht kürzer als {{min_length}} Zeichen",
    constraint_min_length_suffix: "sein",
    constraint_regex_prefix: "muss",
    constraint_regex: "dem regulären Ausdruck '{{regex}}'",
    constraint_regex_suffix: "entsprechen"
  });

  $.extend(locales.en, {
    dependency_general: "This field's dependencies must be correctly filled in first",
    dependency_prefix: "The fields",
    dependency_suffix: "must be filled in correctly",
    dependency_singular_prefix: "The field",
    dependency_singular_suffix: "must be filled in correctly",
    value_email: "'{{value}}' address must be of the form 'my.address@provider.ending'",
    value_email_at: "'{{value}}' address must contain an @ symbol",
    value_email_many_at: "'{{value}}' address can only have one @ symbol",
    value_email_dot: "'{{value}}' must have a correct ending (i.e. '.com')",
    value_integer: "'{{value}}' must be an integer",
    value_integer_float: "'{{value}}' must not be decimal",
    value_number: "'{{value}}' must be a number",
    value_phone: "'{{value}}' can only contain numbers, spaces, and the characters '+-/()'",
    value_radio: "One of the radio buttons must be selected",
    value_checkbox: "The checkbox must be selected",
    value_select: "Another option must be selected",
    value_text: "Please fill in this text field",
    constraint_enumerate_prefix: "'{{value}}'",
    constraint_list_prefix: "'{{value}}'",
    constraint_blacklist_prefix: "must not",
    constraint_blacklist: "contain any of the characters '{{blacklist}}'",
    constraint_blacklist_suffix: "",
    constraint_whitelist_prefix: "must",
    constraint_whitelist: "contain each of the characters '{{whitelist}}'",
    constraint_whitelist_suffix: "",
    constraint_max_prefix: "must not",
    constraint_max: "be greater than or equal to {{max}}",
    constraint_max_suffix: "",
    constraint_max_include_max_prefix: "must not",
    constraint_max_include_max: "be greater than {{max}}",
    constraint_max_include_max_suffix: "",
    constraint_max_length_prefix: "must not",
    constraint_max_length: "be longer than {{max_length}} characters",
    constraint_max_length_suffix: "",
    constraint_min_prefix: "must not",
    constraint_min: "be less than or equal to {{min}}",
    constraint_min_suffix: "",
    constraint_min_include_min_prefix: "must not",
    constraint_min_include_min: "be less than {{min}}",
    constraint_min_include_min_suffix: "",
    constraint_min_length_prefix: "must not",
    constraint_min_length: "be shorter than {{min_length}} characters",
    constraint_min_length_suffix: "",
    constraint_regex_prefix: "must",
    constraint_regex: "match the regular expression '{{regex}}'",
    constraint_regex_suffix: ""
  });

  locale_build_mode_helpers = {
    de: {},
    en: {}
  };

  build_mode_helpers = {};

  build_mode_helpers[BUILD_MODES.ENUMERATE] = function(parts, locale, phase, build_mode) {
    var first_part, lang_data, last_part, new_parts, part, parts_grouped_by_prefix, parts_grouped_by_suffix, prefix, prefix_group, suffix, suffix_group;
    if (parts.length > 1) {
      lang_data = locales[locale];
      new_parts = [];
      parts_grouped_by_suffix = group_arr_by(parts, function(part) {
        return part.suffix;
      });
      for (suffix in parts_grouped_by_suffix) {
        suffix_group = parts_grouped_by_suffix[suffix];
        parts_grouped_by_prefix = group_arr_by(suffix_group, function(part) {
          return part.prefix;
        });
        for (prefix in parts_grouped_by_prefix) {
          prefix_group = parts_grouped_by_prefix[prefix];
          first_part = prefix_group[0];
          first_part.message = first_part.prefix + " " + first_part.message;
        }
        last_part = suffix_group[suffix_group.length - 1];
        last_part.message = last_part.message + " " + last_part.suffix;
        new_parts = new_parts.concat(suffix_group);
      }
      parts = new_parts;
      return ((((function() {
        var l, len, ref, results1;
        ref = parts.slice(0, -1);
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          part = ref[l];
          results1.push(part.message);
        }
        return results1;
      })()).join(", ")) + " " + lang_data["and"] + " " + parts[parts.length - 1].message).replace(/\s+/g, " ");
    }
    return (parts[0].prefix + " " + parts[0].message + " " + parts[0].suffix).replace(/\s+/g, " ");
  };

  build_mode_helpers[BUILD_MODES.SENTENCE] = function(parts, locale, build_mode) {
    var part;
    return ((function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = parts.length; l < len; l++) {
        part = parts[l];
        results1.push("" + (part.message[0].toUpperCase()) + (part.message.slice(1)));
      }
      return results1;
    })()).join(". ").replace(/\s+/g, " ");
  };

  build_mode_helpers[BUILD_MODES.LIST] = function(parts, locale, build_mode) {
    return "<ul><li>" + (parts.join("</li><li>")) + "</li></ul>";
  };

  default_message_builder = function(key, phase, build_mode, locale, parts, prefix, suffix, prefix_delimiter, suffix_delimiter) {
    var base, message;
    if (prefix_delimiter == null) {
      prefix_delimiter = " ";
    }
    if (suffix_delimiter == null) {
      suffix_delimiter = " ";
    }
    prefix = prefix || locales[locale][key + "_prefix"] || "";
    suffix = suffix || locales[locale][key + "_suffix"] || "";
    if (parts instanceof Array) {
      message = (typeof (base = locale_build_mode_helpers[locale])[build_mode] === "function" ? base[build_mode](parts, locale, phase, build_mode) : void 0) || build_mode_helpers[build_mode](parts, locale, phase, build_mode);
    } else {
      message = parts;
    }
    if (prefix) {
      if (prefix instanceof Function) {
        prefix = prefix();
      }
      message = prefix + prefix_delimiter + message;
    }
    if (suffix) {
      message += suffix_delimiter + suffix;
    }
    return message;
  };

  part_evaluator = function() {
    var key, part, val, values;
    part = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (values.length === 1) {
      values = values[0];
    } else {
      values = $.extend.apply($, values);
    }
    if (typeof part === "string") {
      for (key in values) {
        val = values[key];
        if (part.indexOf("{{" + key + "}}") >= 0) {
          part = part.replace("{{" + key + "}}", val);
        }
      }
      return part;
    }
    if (part instanceof Function) {
      return part(values);
    }
    return "";
  };

  error_message_builders = {};

  error_message_builders[VALIDATION_PHASES.DEPENDENCIES] = function(errors, phase, build_mode, locale) {
    var error, key, name, names, parts;
    names = (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = errors.length; l < len; l++) {
        error = errors[l];
        if (error.name != null) {
          results1.push(error.name);
        }
      }
      return results1;
    })();
    if (names.length === errors.length) {
      if (build_mode === BUILD_MODES.SENTENCE) {
        build_mode = BUILD_MODES.ENUMERATE;
      }
      parts = (function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = names.length; l < len; l++) {
          name = names[l];
          results1.push({
            message: "'" + name + "'",
            prefix: "",
            suffix: ""
          });
        }
        return results1;
      })();
      key = VALIDATION_PHASES_SINGULAR[phase].toLowerCase();
      if (parts.length === 1) {
        key += "_singular";
      }
      return default_message_builder(key, phase, build_mode, locale, parts);
    }
    return locales[locale][(VALIDATION_PHASES_SINGULAR[phase].toLowerCase()) + "_general"];
  };

  error_message_builders[VALIDATION_PHASES.VALUE] = function(errors, phase, build_mode, locale) {
    var error, key, part;
    error = errors[0];
    key = (VALIDATION_PHASES_SINGULAR[phase].toLowerCase()) + "_" + (error.error_message_type || error.type);
    part = {
      message: part_evaluator(locales[locale][key], error),
      prefix: "",
      suffix: ""
    };
    return default_message_builder(key, phase, BUILD_MODES.ENUMERATE, locale, [part]);
  };

  error_message_builders[VALIDATION_PHASES.CONSTRAINTS] = function(errors, phase, build_mode, locale) {
    var default_prefix, default_suffix, error, error_in_group, group, grouped_errors, i, key, key_prefix, keys, l, len, len1, len2, len3, len4, m, o, option, parts, phase_singular, prefix, q, ref, ref1, t, ungrouped_errors, val;
    parts = [];
    grouped_errors = [];
    ungrouped_errors = [];
    for (l = 0, len = errors.length; l < len; l++) {
      error = errors[l];
      error_in_group = false;
      for (i = m = 0, len1 = constraint_validator_groups.length; m < len1; i = ++m) {
        group = constraint_validator_groups[i];
        if (ref = error.type, indexOf.call(group, ref) >= 0) {
          error_in_group = true;
          if (grouped_errors[i] != null) {
            grouped_errors[i].push(error);
          } else {
            grouped_errors[i] = [error];
          }
        }
      }
      if (!error_in_group) {
        ungrouped_errors.push(error);
      }
    }
    for (o = 0, len2 = ungrouped_errors.length; o < len2; o++) {
      error = ungrouped_errors[o];
      grouped_errors.push([error]);
    }
    phase_singular = VALIDATION_PHASES_SINGULAR[phase].toLowerCase();
    key_prefix = phase_singular + "_";
    default_prefix = locales[locale][(phase + "_" + build_mode + "_prefix").toLowerCase()] || "";
    default_suffix = locales[locale][(phase + "_" + build_mode + "_suffix").toLowerCase()] || "";
    for (q = 0, len3 = grouped_errors.length; q < len3; q++) {
      errors = grouped_errors[q];
      if (!(errors != null)) {
        continue;
      }
      keys = [];
      for (t = 0, len4 = errors.length; t < len4; t++) {
        error = errors[t];
        keys.push(error.type);
        if (error.options != null) {
          ref1 = error.options;
          for (option in ref1) {
            val = ref1[option];
            if (include_constraint_option_in_locale_key(option, val)) {
              keys.push(option);
            }
          }
        }
      }
      key = get_combined_key(keys, locale, key_prefix);
      if (key != null) {
        parts.push({
          message: part_evaluator.apply(null, [locales[locale][key]].concat(slice.call(errors))),
          prefix: part_evaluator(locales[locale][key + "_prefix"], error) || default_prefix,
          suffix: part_evaluator(locales[locale][key + "_suffix"], error) || default_suffix
        });
      } else if (DEBUG) {
        throw new Error("Could not find a translation for key while trying to create an error message during the constraint validation phase. The keys that were retrieved from the generated errors are: " + (JSON.stringify(keys)) + ". Define an according key in the 'locales' variable (e.g. '" + key_prefix + (keys.join("_")) + "')!");
      }
    }
    key = phase_singular + "_" + (build_mode.toLowerCase());
    prefix = part_evaluator("" + locales[locale][key + "_prefix"], errors[0]);
    return default_message_builder(key, phase, build_mode, locale, parts, prefix);
  };

  permutation_cache = {};

  get_combined_key = function(keys, locale, key_prefix, key_suffix) {
    var cache_key, k, key, l, len, len1, m, o, permutation, ref, ref1, ref2, subset;
    if (key_prefix == null) {
      key_prefix = "";
    }
    if (key_suffix == null) {
      key_suffix = "";
    }
    keys = keys.slice(0);
    keys.sort();
    cache_key = keys.join("_");
    if (permutation_cache[cache_key] != null) {
      return permutation_cache[cache_key];
    }
    for (k = l = ref = keys.length; l > 0; k = l += -1) {
      ref1 = get_subsets(keys, k);
      for (m = 0, len = ref1.length; m < len; m++) {
        subset = ref1[m];
        ref2 = get_permutations(subset);
        for (o = 0, len1 = ref2.length; o < len1; o++) {
          permutation = ref2[o];
          key = key_prefix + permutation.join("_") + key_suffix;
          if (locales[locale][key] != null) {
            permutation_cache[cache_key] = key;
            return key;
          }
        }
      }
    }
    return null;
  };

  FormModifier = (function() {
    function FormModifier(form_validator, options) {
      this.form_validator = form_validator;
      if ((ERROR_OUTPUT_MODES[options.error_output_mode] != null) || options.error_output_mode instanceof Function) {
        this.error_output_mode = options.error_output_mode;
      } else {
        this.error_output_mode = ERROR_OUTPUT_MODES.DEFAULT;
      }
    }

    FormModifier.prototype._apply_error_classes = function(element, error_targets, classes, is_valid) {
      var i, l, len, target, targets;
      if (error_targets != null) {
        targets = this.form_validator._find_targets(error_targets, element);
        for (i = l = 0, len = targets.length; l < len; i = ++l) {
          target = targets[i];
          if (!(target instanceof jQuery)) {
            target = targets.eq(i);
          }
          if (is_valid === false) {
            target.addClass(classes);
          } else {
            target.removeClass(classes);
          }
        }
        return targets;
      }
      return [];
    };

    FormModifier.prototype._set_message_below = function(message, element, data) {
      var target;
      if ((target = element.data("_fv_error_container")) == null) {
        if (data.type === "radio") {
          element = $("input[name='" + (element.attr("name")) + "']").last();
        }
        if ((target = element.next(".fv-error-message")).length === 0) {
          target = $("<div class=\"fv-error-message\" />");
          element.after(target);
        }
        element.data("_fv_error_container", target);
      }
      target.html(message);
      return this;
    };

    FormModifier.prototype._set_message_tooltip = function(message, element, data) {
      if (element.data("_fv_tooltip") == null) {
        element.tooltip({
          html: true,
          placement: element.attr("data-placement") || "top",
          title: function() {
            return $(this).data("_fv_tooltip");
          }
        });
      }
      element.data("_fv_tooltip", message).tooltip("hide");
      return this;
    };

    FormModifier.prototype._set_message_popover = function(message, element, data) {
      if (data.type === "checkbox" || data.type === "radio" || data.type === "select") {
        element.attr("title", message);
        return this;
      }
      if (element.data("_fv_popover") == null) {
        element.popover({
          html: true,
          placement: element.attr("data-placement") || "right",
          content: function() {
            return $(this).data("_fv_popover");
          },
          trigger: "manual"
        }).focus(function() {
          element.popover("show");
          return false;
        }).blur(function() {
          element.popover("hide");
          return true;
        }).click(function() {
          if (document.activeElement === this) {
            element.popover("toggle");
          }
          return true;
        });
      }
      element.data("_fv_popover", message).popover("hide");
      return this;
    };

    FormModifier.prototype._process_error_message = function(message, element, data) {
      var error_output_mode, target;
      if (this.error_output_mode === ERROR_OUTPUT_MODES.NONE) {
        return this;
      }
      if (this.error_output_mode instanceof Function) {
        target = this.error_output_mode(element, data, message);
        target.html(message);
      } else {
        error_output_mode = this.error_output_mode.toLowerCase();
        this["_set_message_" + error_output_mode](message, element, data);
      }
      return this;
    };

    FormModifier.prototype.modify = function(grouped_errors, options) {
      var data, elem, err, error, error_output_mode, fields, form_validator, grouped_error, i, is_valid, l, len, len1, m, message, o, ref, ref1, valid_dependencies;
      form_validator = this.form_validator;
      fields = form_validator.fields.all;
      error_output_mode = form_validator.error_output_mode;
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = form_validator._get_element_data(elem);
        grouped_error = null;
        for (m = 0, len = grouped_errors.length; m < len; m++) {
          err = grouped_errors[m];
          if (!(err.element.is(elem))) {
            continue;
          }
          grouped_error = err;
          break;
        }
        if (grouped_error == null) {
          is_valid = true;
          valid_dependencies = true;
          message = "";
        } else {
          is_valid = false;
          valid_dependencies = true;
          ref1 = grouped_error.errors;
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            error = ref1[o];
            if (!(error.phase === VALIDATION_PHASES.DEPENDENCIES)) {
              continue;
            }
            valid_dependencies = false;
            break;
          }
          message = grouped_error.message;
        }
        if (options.apply_error_classes === true) {
          this._apply_error_classes(elem, data.error_targets, data["error_classes"] || form_validator["error_classes"], is_valid);
          this._apply_error_classes(elem, data.depends_on, data["dependency_error_classes"] || form_validator["dependency_error_classes"], valid_dependencies);
        }
        this._process_error_message(message, elem, data);
      }
      return this;
    };

    return FormModifier;

  })();

  window.FormValidator = (function() {
    FormValidator.ERROR_MODES = ERROR_MODES;

    FormValidator.ERROR_OUTPUT_MODES = ERROR_OUTPUT_MODES;

    FormValidator.VALIDATION_PHASES = VALIDATION_PHASES;

    FormValidator.BUILD_MODES = BUILD_MODES;

    FormValidator.ERROR_MESSAGE_CONFIG = ERROR_MESSAGE_CONFIG;

    FormValidator.constraint_validators = constraint_validators;

    FormValidator.constraint_validator_options = constraint_validator_options;

    FormValidator.constraint_validator_groups = constraint_validator_groups;

    FormValidator.validators = validators;

    FormValidator.locales = locales;

    FormValidator.error_message_builders = error_message_builders;

    FormValidator.default_preprocessors = {
      number: function(str, elem, locale) {
        if (locale === "de") {
          return str.replace(/\,/g, ".");
        }
        return str;
      },
      integer: function(str, elem, locale) {
        if (locale === "de") {
          return str.replace(/\,/g, ".");
        }
        return str;
      }
    };

    FormValidator._build_error_message = function(phase, errors, build_mode, locale) {
      return this.error_message_builders[phase](errors, phase, build_mode, locale);
    };

    FormValidator.get_error_message_for_element = function(element, errors, build_mode, locale, delimiter) {
      var error, error_message_parts, grouped_errors, l, len, phase, ref;
      if (delimiter == null) {
        delimiter = " ";
      }
      error_message_parts = [];
      grouped_errors = {};
      for (phase in VALIDATION_PHASES) {
        grouped_errors[phase] = (function() {
          var l, len, results1;
          results1 = [];
          for (l = 0, len = errors.length; l < len; l++) {
            error = errors[l];
            if (error.phase === phase) {
              results1.push(error);
            }
          }
          return results1;
        })();
      }
      ref = this.ERROR_MESSAGE_CONFIG.PHASE_ORDER;
      for (l = 0, len = ref.length; l < len; l++) {
        phase = ref[l];
        if (grouped_errors[phase].length > 0) {
          error_message_parts.push(this._build_error_message(phase, grouped_errors[phase], build_mode, locale));
        }
      }
      return error_message_parts.join(delimiter);
    };

    $(document).on("click", "[data-fv-start]", function() {
      var $elem, container, error, error1, form_validator, options;
      $elem = $(this);
      if ((container = $elem.data("_form_validator_container")) == null) {
        container = $elem.closest($elem.attr("data-fv-start"));
        if (container.length === 0) {
          container = $($elem.attr("data-fv-start"));
        }
        $elem.data("_form_validator_container", container);
      }
      if (DEBUG && container.length === 0) {
        throw new Error("FormValidator (in validation on click triggered by 'data-fv-start'): No container found. Check the value of the 'data-fv-start' attribute (so it matches a closest element or any element in the document)!");
      }
      if ((form_validator = container.data("_form_validator")) == null) {
        options = $elem.attr("data-fv-start-options");
        if (options != null) {
          try {
            options = JSON.parse(options);
          } catch (error1) {
            error = error1;
            options = window[options]();
          }
        }
        form_validator = FormValidator["new"](container, options);
        container.data("_form_validator", form_validator);
      }
      form_validator.validate();
      return false;
    });

    $(document).on("change click keyup", "[data-fv-real-time] [data-fv-validate]", function(evt) {
      var $elem, container, errors, form_validator;
      $elem = $(this);
      if ((evt.type === "click" || evt.type === "change") && $elem.filter("textarea, input[type='text'], input[type='number'], input[type='date'], input[type='month'], input[type='week'], input[type='time'], input[type='datetime'], input[type='datetime-local'], input[type='email'], input[type='search'], input[type='url']").length === $elem.length) {
        return true;
      }
      container = $elem.closest("[data-fv-real-time]");
      if (container.length === 1) {
        if ((form_validator = container.data("_form_validator")) == null) {
          form_validator = FormValidator["new"](container);
          container.data("_form_validator", form_validator);
        }
        errors = form_validator.validate();
        if (errors.length > 0) {
          $elem.focus();
        }
      }
      return false;
    });

    FormValidator["new"] = function(form, options) {
      if (DEBUG && !(form instanceof jQuery)) {
        throw new Error("FormValidator::constructor: Invalid form given (must be a jQuery object)!");
      }
      return new this(form, options);
    };


    /**
    * @param form {Form}
    * @param options {Object}
    *
     */

    function FormValidator(form, options) {
      var CLASS;
      if (options == null) {
        options = {};
      }
      CLASS = this.constructor;
      this.form = form;
      this.fields = null;
      this.form_modifier = new FormModifier(this, options);
      this.error_classes = options.error_classes || this.form.attr("data-fv-error-classes") || "";
      this.dependency_error_classes = options.dependency_error_classes || this.form.attr("data-fv-dependency-error-classes") || "";
      this.validators = $.extend({}, CLASS.validators, options.validators);
      this.validation_options = options.validation_options || null;
      this.constraint_validators = $.extend({}, CLASS.constraint_validators, options.constraint_validators);
      this.build_mode = options.build_mode || BUILD_MODES.DEFAULT;
      this.error_mode = CLASS.ERROR_MODES[options.error_mode] != null ? options.error_mode : CLASS.ERROR_MODES.DEFAULT;
      this.locale = options.locale || "en";
      this.error_target_getter = options.error_target_getter || null;
      this.field_getter = options.field_getter || null;
      this.required_field_getter = options.required_field_getter || null;
      this.create_dependency_error_message = options.create_dependency_error_message || null;
      this.preprocessors = $.extend(CLASS.default_preprocessors, options.preprocessors || {});
      this.postprocessors = options.postprocessors || {};
      this.group = options.group || null;
      this.process_errors = options.process_errors || null;
    }

    FormValidator.prototype._get_attribute_value_for_key = function(element, key) {
      var attribute, boolean, has_attr, k, prefix, ref, special, value;
      prefix = "data-fv-";
      special = {
        type: "validate",
        required: "optional"
      };
      boolean = ["preprocess", "required"];
      if (special[key] == null) {
        attribute = prefix + key.replace(/\_/g, "-");
      } else {
        attribute = prefix + special[key];
      }
      value = element.attr(attribute);
      has_attr = (value != null);
      if (has_attr) {
        value = value.trim();
      } else {
        if (ref = (k = key.toUpperCase()), indexOf.call(Object.keys(DEFAULT_ATTR_VALUES), ref) >= 0) {
          value = DEFAULT_ATTR_VALUES[k];
        }
      }
      if (indexOf.call(boolean, key) >= 0) {
        value = value === "true" || value === true ? true : false;
      }
      if (key === "required" && has_attr) {
        value = !value;
      }
      return value;
    };

    FormValidator.prototype._set_element_data = function(element, data) {
      $.data(element[0], "_fv", data);
      return this;
    };

    FormValidator.prototype._get_element_data = function(element) {
      return $.data(element[0], "_fv");
    };

    FormValidator.prototype._cache_attribute = function(element, data, key, value) {
      if (value == null) {
        value = element.attr("data-fv-" + (key.replace(/\_/g, "-")));
      } else if (value instanceof Function) {
        value = value.call(this);
      }
      data[key] = value;
      return data;
    };

    FormValidator.prototype._get_fields = function(form) {
      return (typeof this.field_getter === "function" ? this.field_getter(form) : void 0) || form.find("[data-fv-validate]").filter(function(idx, elem) {
        return $(elem).closest("[data-fv-ignore-children]").length === 0;
      });
    };

    FormValidator.prototype._get_required = function(fields) {
      return (typeof this.required_field_getter === "function" ? this.required_field_getter(fields) : void 0) || fields.not("[data-fv-optional='true']");
    };

    FormValidator.prototype._get_value_info = function(element, data) {
      var original_value, preprocess, type, usedValFunc, value, value_has_changed;
      type = data.type, preprocess = data.preprocess;
      usedValFunc = true;
      value = element.val();
      if (value == null) {
        usedValFunc = false;
        value = element.text();
      }
      original_value = value;
      value_has_changed = original_value !== data.value;
      data.value = original_value;
      if ((this.preprocessors[type] != null) && preprocess !== false) {
        value = this.preprocessors[type].call(this.preprocessors, value, element, this.locale);
      }
      return {
        usedValFunc: usedValFunc,
        value: value,
        original_value: original_value,
        value_has_changed: value_has_changed
      };
    };

    FormValidator.prototype._find_targets = function(targets, element, delimiter) {
      var target;
      if (delimiter == null) {
        delimiter = /\s+/g;
      }
      if (typeof targets === "string") {
        return (function() {
          var l, len, ref, results1;
          ref = targets.split(delimiter);
          results1 = [];
          for (l = 0, len = ref.length; l < len; l++) {
            target = ref[l];
            results1.push(this._find_target(target, element));
          }
          return results1;
        }).call(this);
      }
      return targets || [];
    };

    FormValidator.prototype._find_target = function(target, element) {
      var result;
      if (target === "self") {
        return element;
      }
      result = this.form.find("[data-fv-name='" + target + "']");
      if (result.length === 0) {
        result = element.closest(target);
      }
      if (result.length === 0) {
        result = this.form.find(target);
      }
      if (result.length === 0) {
        result = $(target);
      }
      return result;
    };

    FormValidator.prototype._get_error_targets = function(element, type) {
      return (typeof this.error_target_getter === "function" ? this.error_target_getter(element, type) : void 0) || element.attr("data-fv-error-targets") || element.closest("[data-fv-error-targets]").attr("data-fv-error-targets") || DEFAULT_ATTR_VALUES.ERROR_TARGETS;
    };

    FormValidator.prototype._group = function(fields) {
      var data, dict, elem, elems, group_name, i, l, name, ref;
      dict = {};
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = this._get_element_data(elem);
        if (data.group == null) {
          data.group = elem.attr("data-fv-group") || data.name;
          this._set_element_data(elem, data);
        }
        group_name = data.group;
        if (dict[group_name] == null) {
          dict[group_name] = [elem];
        } else {
          dict[group_name].push(elem);
        }
      }
      return (function() {
        var results1;
        results1 = [];
        for (name in dict) {
          elems = dict[name];
          results1.push(elems);
        }
        return results1;
      })();
    };

    FormValidator.prototype._group_errors = function(errors, options) {
      var CLASS, elem, elem_errors, error, fields, i, l, message, ref, result;
      CLASS = this.constructor;
      result = [];
      fields = this.fields.all;
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        elem_errors = (function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = errors.length; m < len; m++) {
            error = errors[m];
            if (error.element.is(elem)) {
              results1.push(error);
            }
          }
          return results1;
        })();
        if (elem_errors.length > 0) {
          if (options.messages === true) {
            message = CLASS.get_error_message_for_element(elem, elem_errors, this.build_mode, this.locale);
          } else {
            message = "";
          }
          result.push({
            element: elem,
            errors: elem_errors,
            message: message
          });
        }
      }
      return result;
    };

    FormValidator.prototype._validate_value = function(element, data, value_info) {
      var type, validation, validator, value;
      type = data.type;
      value = value_info.value;
      validator = this.validators[type];
      if (validator == null) {
        throw new Error("FormValidator::_validate_value: No validator found for type '" + type + "'. Make sure the type is correct or define a validator!");
      }
      validation = validator.call(this.validators, value, element);
      if (validation === false) {
        validation = {
          error_message_type: type
        };
      } else if (typeof validation === "string") {
        validation = {
          error_message_type: validation
        };
      }
      return validation;
    };

    FormValidator.prototype._validate_dependencies = function(element, data, options) {
      var dependency_data, dependency_elem, dependency_validation, elements, errors, i, l, len, valid;
      errors = [];
      elements = data.depends_on;
      for (i = l = 0, len = elements.length; l < len; i = ++l) {
        dependency_elem = elements[i];
        dependency_data = this._get_element_data(dependency_elem);
        dependency_validation = this._validate_element(dependency_elem, dependency_data, this._get_value_info(dependency_elem, dependency_data), options);
        if (dependency_validation !== true) {
          errors.push($.extend(dependency_validation, {
            dependency_element: dependency_elem,
            element: element,
            index: i,
            type: dependency_data.type,
            name: dependency_data.name
          }));
        }
      }
      if (data.dependency_mode == null) {
        data.dependency_mode = element.attr("data-fv-dependency-mode") || DEFAULT_ATTR_VALUES.DEPENDENCY_MODE;
        this._set_element_data(element, data);
      }
      if (data.dependency_mode === "any") {
        valid = errors.length < elements.length;
      } else {
        valid = errors.length === 0;
      }
      return {
        dependency_errors: errors,
        dependency_elements: elements,
        valid_dependencies: valid,
        dependency_mode: data.dependency_mode
      };
    };

    FormValidator.prototype._validate_constraints = function(element, data, value) {
      var CLASS, constraint, constraint_name, constraint_validator, constraint_value, constraints, l, len, len1, m, option, options, ref, result, results;
      results = {};
      if (data.constraints != null) {
        constraints = data.constraints;
      } else {
        CLASS = this.constructor;
        constraints = [];
        ref = this.constraint_validators;
        for (constraint_name in ref) {
          constraint_validator = ref[constraint_name];
          if ((constraint_value = element.attr("data-fv-" + (constraint_name.replace(/\_/g, "-")))) != null) {
            if ((constraint_validator_options = CLASS.constraint_validator_options[constraint_name]) != null) {
              options = {};
              for (l = 0, len = constraint_validator_options.length; l < len; l++) {
                option = constraint_validator_options[l];
                options[option] = element.attr("data-fv-" + (option.replace(/\_/g, "-"))) || DEFAULT_ATTR_VALUES[option.toUpperCase()];
              }
            } else {
              options = null;
            }
            constraints.push({
              name: constraint_name,
              options: options,
              validator: constraint_validator,
              value: constraint_value
            });
          }
        }
        data.constraints = constraints;
        this._set_element_data(element, data);
      }
      for (m = 0, len1 = constraints.length; m < len1; m++) {
        constraint = constraints[m];
        if (constraint.validator.call(this.constraint_validators, value, constraint.value, constraint.options) === true) {
          results[constraint.name] = true;
        } else {
          result = {};
          result.options = constraint.options;
          result[constraint.name] = constraint.value;
          results[constraint.name] = result;
        }
      }
      return results;
    };

    FormValidator.prototype._validate_element = function(elem, data, value_info, options) {
      var constraint_name, current_error, dependency_elements, dependency_error, dependency_errors, dependency_mode, errors, is_required, l, len, original_value, phase, prev_phases_valid, ref, ref1, ref2, ref3, result, temp, type, usedValFunc, valid_dependencies, validation_res, value, value_has_changed;
      errors = [];
      prev_phases_valid = true;
      is_required = data.required;
      type = data.type;
      value = value_info.value, original_value = value_info.original_value, value_has_changed = value_info.value_has_changed, usedValFunc = value_info.usedValFunc;
      phase = VALIDATION_PHASES.DEPENDENCIES;
      ref = this._validate_dependencies(elem, data, options), dependency_errors = ref.dependency_errors, dependency_elements = ref.dependency_elements, dependency_mode = ref.dependency_mode, valid_dependencies = ref.valid_dependencies;
      if (!valid_dependencies) {
        prev_phases_valid = false;
        data.valid_dependencies = false;
        console.log(dependency_errors);
        for (l = 0, len = dependency_errors.length; l < len; l++) {
          dependency_error = dependency_errors[l];
          $.extend(dependency_error, {
            element: elem,
            required: is_required,
            type: "dependency",
            phase: phase,
            mode: dependency_mode
          });
        }
        data.errors[phase] = dependency_errors;
      } else {
        data.valid_dependencies = true;
        data.errors[phase] = [];
      }
      errors = errors.concat(data.errors[phase]);
      phase = VALIDATION_PHASES.VALUE;
      if (value_has_changed) {
        if (prev_phases_valid || !options.stop_on_error) {
          current_error = null;
          validation_res = this._validate_value(elem, data, value_info);
          if (validation_res !== true) {
            prev_phases_valid = false;
            data.valid_value = false;
            current_error = {
              element: elem,
              error_message_type: validation_res.error_message_type,
              phase: phase,
              required: is_required,
              type: type,
              value: value
            };
            data.errors[phase] = [current_error];
          } else {
            data.valid_value = true;
            data.errors[phase] = [];
          }
        }
      } else {
        if (prev_phases_valid || !options.stop_on_error) {
          if (data.valid_value !== true) {
            prev_phases_valid = false;
          }
        }
      }
      errors = errors.concat(data.errors[phase]);
      phase = VALIDATION_PHASES.CONSTRAINTS;
      if (value_has_changed) {
        if (prev_phases_valid || !options.stop_on_error) {
          data.valid_constraints = true;
          temp = [];
          ref1 = this._validate_constraints(elem, data, value);
          for (constraint_name in ref1) {
            result = ref1[constraint_name];
            if (!(result !== true)) {
              continue;
            }
            data.valid_constraints = false;
            prev_phases_valid = false;
            temp.push($.extend(result, {
              element: elem,
              required: is_required,
              type: constraint_name,
              phase: phase,
              value: value
            }));
          }
          data.errors[phase] = temp;
        }
      } else {
        if (prev_phases_valid || !options.stop_on_error) {
          if (data.valid_constraints !== true) {
            prev_phases_valid = false;
          }
        }
      }
      errors = errors.concat(data.errors[phase]);
      if (data.valid_dependencies && data.valid_value && data.valid_constraints) {
        if (data.valid !== true || (data.postprocess == null) || (data.output_preprocessed == null)) {
          data.valid = true;
          this._cache_attribute(elem, data, "postprocess");
          this._cache_attribute(elem, data, "output_preprocessed");
          this._set_element_data(elem, data);
        }
        if (data.postprocess === true) {
          value = (ref2 = this.postprocessors[type]) != null ? ref2.call(this.postprocessors, value, elem, this.locale) : void 0;
          if (usedValFunc) {
            elem.val(value);
          } else {
            elem.text(value);
          }
          if (current_error != null) {
            current_error.value = value;
          }
        } else if (data.output_preprocessed === true) {
          value = (ref3 = this.preprocessors[type]) != null ? ref3.call(this.preprocessors, value, elem, this.locale) : void 0;
          if (usedValFunc) {
            elem.val(value);
          } else {
            elem.text(value);
          }
          if (current_error != null) {
            current_error.value = value;
          }
        }
      } else {
        if (data.valid !== false) {
          data.valid = false;
          this._set_element_data(elem, data);
        }
      }
      if (options.apply_error_classes === true && (data.error_targets == null)) {
        this._cache_attribute(elem, data, "error_targets", function() {
          return this._get_error_targets(elem, type);
        });
        this._set_element_data(elem, data);
      }
      return errors;
    };

    FormValidator.prototype.register_validator = function(type, validator, error_message_types) {
      if (DEBUG) {
        if (validator.call instanceof Function && typeof (validator.call(this.validators, "", $())) === "boolean" && validator.error_message_types instanceof Array) {
          this.validators[type] = validator;
        } else {
          console.warn("FormValidator::register_validator: Invalid validator given (has no call method or not returning a boolean)!");
        }
      } else {
        this.validators[type] = validator;
      }
      return this;
    };

    FormValidator.prototype.deregister_validator = function(type) {
      delete this.validators[type];
      return this;
    };

    FormValidator.prototype.register_preprocessor = function(type, processor) {
      this.preprocessors[type] = processor;
      return this;
    };

    FormValidator.prototype.deregister_preprocessor = function(type) {
      delete this.preprocessors;
      return this;
    };

    FormValidator.prototype.register_postprocessor = function(type, processor) {
      this.postprocessors[type] = processor;
      return this;
    };

    FormValidator.prototype.deregister_postprocessor = function(type) {
      delete this.postprocessors[type];
      return this;
    };

    FormValidator.prototype.cache = function() {
      var data, elem, fields, i, key, l, len, len1, m, o, ref;
      fields = this._get_fields(this.form);
      this.fields = {
        all: fields,
        required: this._get_required(fields)
      };
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = {};
        for (m = 0, len = REQUIRED_CACHE.length; m < len; m++) {
          key = REQUIRED_CACHE[m];
          data[key] = this._get_attribute_value_for_key(elem, key);
        }
        data.depends_on = this._find_targets(data.depends_on, elem, /^\s*\;\s*$/g);
        data.id = i;
        for (o = 0, len1 = OPTIONAL_CACHE.length; o < len1; o++) {
          key = OPTIONAL_CACHE[o];
          data[key] = null;
        }
        data.errors = {};
        data.errors[VALIDATION_PHASES.DEPENDENCIES] = [];
        data.errors[VALIDATION_PHASES.VALUE] = [];
        data.errors[VALIDATION_PHASES.CONSTRAINTS] = [];
        this._set_element_data(elem, data);
      }
      return this;
    };


    /**
    * @method validate
    * @param options {Object}
    * Default is this.validation_option. Otherwise:
    * Valid options are:
    *  - all:                   {Boolean} (default is false)
    *  - apply_error_classes:   {Boolean} (default is true)
    *  - focus_invalid:         {Boolean} (default is true)
    *  - messages:              {Boolean} (default is true)
    *  - stop_on_error:         {Boolean} (default is true)
    *    -> stop the current validation after an error has been found (otherwise all errors will be collected)
    *  - recache:               {Boolean} (default is false)
    *
     */

    FormValidator.prototype.validate = function(options) {
      var CLASS, data, default_options, dep, dep_data, dependency_data, deps, elem, elem_errors, errors, fields, first_invalid_element, grouped_errors, i, id, id_to_elem, is_required, l, len, len1, m, name, o, original_value, ref, ref1, required, type, usedValFunc, value, value_has_changed, value_info;
      if (options == null) {
        options = {};
      }
      default_options = {
        all: false,
        apply_error_classes: true,
        focus_invalid: true,
        messages: true,
        stop_on_error: true,
        recache: false
      };
      options = $.extend(default_options, this.validation_options, options);
      if ((this.fields == null) || options.recache === true) {
        this.cache();
      }
      CLASS = this.constructor;
      errors = [];
      usedValFunc = false;
      required = this.fields.required;
      fields = this.fields.all;
      first_invalid_element = null;
      dependency_data = {};
      id_to_elem = {};
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = this._get_element_data(elem);
        id_to_elem[data.id] = elem;
        deps = [];
        ref1 = data.depends_on;
        for (m = 0, len = ref1.length; m < len; m++) {
          dep = ref1[m];
          dep_data = this._get_element_data(dep);
          deps.push(dep_data.id);
        }
        dependency_data[data.id] = deps.join(" ");
      }
      fields = (function() {
        var len1, o, ref2, results1;
        ref2 = toposort(dependency_data);
        results1 = [];
        for (o = 0, len1 = ref2.length; o < len1; o++) {
          id = ref2[o];
          results1.push(id_to_elem[id]);
        }
        return results1;
      })();
      console.log(fields);
      for (o = 0, len1 = fields.length; o < len1; o++) {
        elem = fields[o];
        data = this._get_element_data(elem);
        is_required = data.required;
        type = data.type, name = data.name;
        value_info = this._get_value_info(elem, data);
        value = value_info.value, original_value = value_info.original_value, value_has_changed = value_info.value_has_changed, usedValFunc = value_info.usedValFunc;
        if (options.all === false && !is_required && (value.length === 0 || type === "radio" || type === "checkbox")) {
          if (data.error_targets == null) {
            data = this._cache_attribute(elem, data, "error_targets", function() {
              return this._get_error_targets(elem, type);
            });
            this._set_element_data(elem, data);
          }
          this._apply_error_classes(elem, data.error_targets, true);
          this._apply_dependency_error_classes(elem, data.depends_on, true);
          continue;
        }
        elem_errors = this._validate_element(elem, data, value_info, options);
        if (elem_errors.length > 0) {
          if (first_invalid_element == null) {
            first_invalid_element = elem;
          }
          errors = errors.concat(elem_errors);
        }
      }
      if (options.focus_invalid === true) {
        if (first_invalid_element != null) {
          first_invalid_element.focus();
        }
      }
      grouped_errors = this._group_errors(errors, options);
      if (typeof this.process_errors === "function") {
        this.process_errors(grouped_errors);
      }
      this.form_modifier.modify(grouped_errors, options);
      return grouped_errors;
    };

    FormValidator.prototype.get_progress = function(options) {
      var all_optional, count, elem, error, errors, fields, found_error, group, groups, i, l, len, len1, len2, len3, m, o, q, required, total;
      if (options == null) {
        options = {
          as_percentage: false,
          recache: false
        };
      }
      if ((this.fields == null) || options.recache === true) {
        this.cache();
      }
      fields = this.fields.all;
      required = this.fields.required;
      groups = (typeof this.group === "function" ? this.group(fields) : void 0) || this._group(fields);
      total = groups.length;
      count = 0;
      errors = this.validate({
        apply_error_classes: false,
        all: true
      });
      for (i = l = 0, len = groups.length; l < len; i = ++l) {
        group = groups[i];
        all_optional = true;
        for (m = 0, len1 = group.length; m < len1; m++) {
          elem = group[m];
          elem = $(elem);
          if (required.index(elem) >= 0) {
            all_optional = false;
            break;
          }
        }
        found_error = false;
        for (o = 0, len2 = group.length; o < len2; o++) {
          elem = group[o];
          elem = $(elem);
          for (q = 0, len3 = errors.length; q < len3; q++) {
            error = errors[q];
            if (!(error.element.is(elem))) {
              continue;
            }
            found_error = true;
            break;
          }
          if (found_error) {
            break;
          }
        }
        if (!found_error) {
          count++;
        }
      }
      if (!options.as_percentage) {
        return {
          count: count,
          total: total
        };
      }
      return count / total;
    };

    return FormValidator;

  })();

}).call(this);
