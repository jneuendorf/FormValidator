// Generated by CoffeeScript 1.10.0
(function() {
  var BUILD_MODES, CONSTRAINT_VALIDATOR_OPTIONS, DEBUG, DEFAULT_ATTR_VALUES, DEPENDENCY_CHANGE_ACTIONS, DEPENDENCY_CHANGE_ACTION_DURATION, ERROR_MESSAGE_CONFIG, ERROR_MODES, ERROR_OUTPUT_MODES, EXPOSED_CONSTANTS, FormModifier, Maker, MessageBuilder, MessageDataCreator, OPTIONAL_CACHE, OrderedDict, REQUIRED_CACHE, VALIDATION_PHASES, VALIDATION_PHASES_SINGULAR, _permutation_cache, constraint_validator_groups, constraint_validator_options_in_locale_key, constraint_validators, dependency_change_actions, get_combined_key, get_permutations, get_subsets, group_arr_by, include_constraint_option_in_locale_key, locale_message_builders, locales, message_builder_helper, message_builders, message_data_creators, parse_deps, part_evaluator, set, set_add, set_remove, toposort, validators,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  DEBUG = true;

  if (Array.prototype.unique == null) {
    Array.prototype.unique = function() {
      var elem, l, len, res;
      res = [];
      for (l = 0, len = this.length; l < len; l++) {
        elem = this[l];
        if (indexOf.call(res, elem) < 0) {
          res.push(elem);
        }
      }
      return res;
    };
  }

  if ($.fn.attrAll == null) {
    $.fn.attrAll = function(propName, delimiter, unique) {
      var result;
      if (delimiter == null) {
        delimiter = " ";
      }
      if (unique == null) {
        unique = true;
      }
      result = [];
      this.each(function(idx, elem) {
        result.push($(elem).attr(propName));
        return true;
      });
      if (unique) {
        result = result.unique();
      }
      return result.join(delimiter);
    };
  }

  get_permutations = function(arr) {
    var permute, results;
    permute = function(arr, memo) {
      var cur, i, l, ref, results1;
      if (memo == null) {
        memo = [];
      }
      results1 = [];
      for (i = l = 0, ref = arr.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        cur = arr.splice(i, 1);
        if (arr.length === 0) {
          results.push(memo.concat(cur));
        }
        permute(arr.slice(), memo.concat(cur));
        results1.push(arr.splice(i, 0, cur[0]));
      }
      return results1;
    };
    results = [];
    permute(arr);
    return results;
  };

  get_subsets = function(set, k) {
    var i, index, j, n, p, r, subsets;
    subsets = [];
    n = set.length;
    p = (function() {
      var l, ref, results1;
      results1 = [];
      for (i = l = 0, ref = k; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results1.push(i);
      }
      return results1;
    })();
    while (true) {
      subsets.push((function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = p.length; l < len; l++) {
          index = p[l];
          results1.push(set[index]);
        }
        return results1;
      })());
      if (p[0] === n - k) {
        break;
      }
      i = k - 1;
      while (i >= 0 && p[i] + k - i === n) {
        i--;
      }
      r = p[i];
      p[i]++;
      j = 2;
      i++;
      while (i < k) {
        p[i] = r + j;
        i++;
        j++;
      }
    }
    return subsets;
  };

  group_arr_by = function(arr, get_prop) {
    var elem, grouped, key, l, len;
    grouped = {};
    for (l = 0, len = arr.length; l < len; l++) {
      elem = arr[l];
      if ((key = typeof get_prop === "function" ? get_prop(elem) : void 0) == null) {
        key = elem;
      }
      if (grouped[key] == null) {
        grouped[key] = [];
      }
      grouped[key].push(elem);
    }
    return grouped;
  };

  toposort = function(targets) {
    var independents, k, l, len, parent, ref, result, reverse_deps;
    targets = parse_deps(targets);
    independents = [];
    (function() {
      var k, results1;
      results1 = [];
      for (k in targets) {
        if (targets[k].cnt === 0) {
          delete targets[k];
          results1.push(independents.push(k));
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    })();
    reverse_deps = [];
    (function() {
      var child, k, results1;
      results1 = [];
      for (k in targets) {
        results1.push((function() {
          var results2;
          results2 = [];
          for (child in targets[k].v) {
            if (reverse_deps[child] == null) {
              reverse_deps[child] = [];
            }
            results2.push(reverse_deps[child].push(k));
          }
          return results2;
        })());
      }
      return results1;
    })();
    result = [];
    while (independents.length > 0) {
      k = independents.pop();
      result.push(k);
      ref = reverse_deps[k] || [];
      for (l = 0, len = ref.length; l < len; l++) {
        parent = ref[l];
        set_remove(targets[parent], k);
        if (targets[parent].cnt === 0) {
          independents.push(parent);
          delete targets[parent];
        }
      }
    }
    for (k in targets) {
      throw new Error("FormValidator::validate: Detected cyclical dependencies. Adjust your dependency definitions");
    }
    return result;
  };

  parse_deps = function(data) {
    var child, children, dep, deps, k, l, len, targets, v;
    targets = {};
    deps = set();
    for (k in data) {
      v = data[k];
      targets[k] = set();
      children = v;
      for (l = 0, len = children.length; l < len; l++) {
        child = children[l];
        if (child === '') {
          continue;
        }
        if (child !== k) {
          set_add(targets[k], child);
        }
        set_add(deps, child);
      }
    }
    for (dep in deps.v) {
      if (!(dep in targets)) {
        targets[dep] = set();
      }
    }
    return targets;
  };

  set = function() {
    return {
      cnt: 0,
      v: {}
    };
  };

  set_add = function(s, e) {
    if (!s.v[e]) {
      s.cnt += 1;
      s.v[e] = true;
    }
    return s;
  };

  set_remove = function(s, e) {
    if (s.v[e]) {
      s.cnt -= 1;
      delete s.v[e];
    }
    return s;
  };

  _permutation_cache = {};

  get_combined_key = function(keys, locale, key_prefix, key_suffix) {
    var cache_key, k, key, l, len, len1, m, o, permutation, ref, ref1, ref2, subset;
    if (key_prefix == null) {
      key_prefix = "";
    }
    if (key_suffix == null) {
      key_suffix = "";
    }
    keys = keys.slice(0);
    keys.sort();
    cache_key = keys.join("_");
    if (_permutation_cache[cache_key] != null) {
      return _permutation_cache[cache_key];
    }
    for (k = l = ref = keys.length; l > 0; k = l += -1) {
      ref1 = get_subsets(keys, k);
      for (m = 0, len = ref1.length; m < len; m++) {
        subset = ref1[m];
        ref2 = get_permutations(subset);
        for (o = 0, len1 = ref2.length; o < len1; o++) {
          permutation = ref2[o];
          key = key_prefix + permutation.join("_") + key_suffix;
          if (locales[locale][key] != null) {
            _permutation_cache[cache_key] = key;
            return key;
          }
        }
      }
    }
    return null;
  };

  ERROR_MODES = {
    NORMAL: "NORMAL",
    SIMPLE: "SIMPLE"
  };

  ERROR_MODES.DEFAULT = ERROR_MODES.NORMAL;

  ERROR_OUTPUT_MODES = {
    BELOW: "BELOW",
    NONE: "NONE",
    POPOVER: "POPOVER",
    TOOLTIP: "TOOLTIP"
  };

  ERROR_OUTPUT_MODES.DEFAULT = ERROR_OUTPUT_MODES.NONE;

  DEPENDENCY_CHANGE_ACTIONS = {
    DISPLAY: "DISPLAY",
    ENABLE: "ENABLE",
    FADE: "FADE",
    NONE: "NONE",
    OPACITY: "OPACITY",
    SHOW: "SHOW",
    SLIDE: "SLIDE"
  };

  DEPENDENCY_CHANGE_ACTIONS.DEFAULT = DEPENDENCY_CHANGE_ACTIONS.NONE;

  DEPENDENCY_CHANGE_ACTION_DURATION = 400;

  VALIDATION_PHASES = {
    DEPENDENCIES: "DEPENDENCIES",
    VALUE: "VALUE",
    CONSTRAINTS: "CONSTRAINTS"
  };

  VALIDATION_PHASES_SINGULAR = {
    DEPENDENCIES: "DEPENDENCY",
    VALUE: "VALUE",
    CONSTRAINTS: "CONSTRAINT"
  };

  BUILD_MODES = {
    ENUMERATE: "ENUMERATE",
    LIST: "LIST",
    SENTENCE: "SENTENCE"
  };

  BUILD_MODES.DEFAULT = BUILD_MODES.ENUMERATE;

  ERROR_MESSAGE_CONFIG = {
    PHASE_ORDER: [VALIDATION_PHASES.DEPENDENCIES, VALIDATION_PHASES.VALUE, VALIDATION_PHASES.CONSTRAINTS],
    BUILD_MODE: BUILD_MODES.DEFAULT
  };

  REQUIRED_CACHE = ["dependency_change_action", "depends_on", "id", "name", "preprocess", "required", "type"];

  OPTIONAL_CACHE = ["dependency_mode", "error_classes", "success_classes", "dependency_error_classes", "error_targets", "group", "output_preprocessed", "postprocess", "constraints", "errors", "valid_constraints", "valid_dependencies", "valid_value", "value"];

  DEFAULT_ATTR_VALUES = {
    PREPROCESS: true,
    POSTPROCESS: false,
    REQUIRED: true,
    OUTPUT_PREPROCESSED: true,
    DEPENDENCY_MODE: "all",
    ERROR_TARGETS: "",
    INCLUDE_MAX: "true",
    INCLUDE_MIN: "true"
  };

  CONSTRAINT_VALIDATOR_OPTIONS = {
    max: ["include_max"],
    max_length: ["enforce_max_length"],
    min: ["include_min"],
    min_length: ["enforce_min_length"],
    regex: ["regex_flags"]
  };

  EXPOSED_CONSTANTS = {
    ERROR_MODES: ERROR_MODES,
    ERROR_OUTPUT_MODES: ERROR_OUTPUT_MODES,
    DEPENDENCY_CHANGE_ACTIONS: DEPENDENCY_CHANGE_ACTIONS,
    VALIDATION_PHASES: VALIDATION_PHASES,
    BUILD_MODES: BUILD_MODES,
    ERROR_MESSAGE_CONFIG: ERROR_MESSAGE_CONFIG
  };

  validators = {
    _number: function(str, elem) {
      var n;
      str = str.replace(/\s/g, "");
      if (str[0] === "+") {
        str = str.slice(1);
      }
      if (str[0] === ".") {
        str = "0" + str;
      } else if (str[0] === "-" && str[1] === ".") {
        str = "-0." + (str.slice(2));
      }
      if (str.indexOf(".") >= 0) {
        while (str[str.length - 1] === "0") {
          str = str.slice(0, -1);
        }
        if (str[str.length - 1] === ".") {
          str = str.slice(0, -1);
        }
      }
      n = parseFloat(str);
      if (isNaN(n) || !isFinite(n) || str !== ("" + n)) {
        return {
          error_message_type: "number",
          _number: n,
          _string: str
        };
      }
      return {
        valid: true,
        _number: n,
        _string: str
      };
    },
    _text: function(str, elem) {
      return str.length > 0;
    },
    email: function(str, elem) {
      var parts;
      if (str.indexOf("@") < 0) {
        return {
          error_message_type: "email_at"
        };
      }
      parts = str.split("@");
      if (parts.length > 2) {
        return {
          error_message_type: "email_many_at"
        };
      }
      if (parts.length === 2 && parts[0] !== "" && parts[1] !== "") {
        if (str.indexOf(".", str.indexOf("@")) < 0 || str[str.length - 1] === ".") {
          return {
            error_message_type: "email_dot"
          };
        }
        return true;
      }
      return {
        error_message_type: "email"
      };
    },
    integer: function(str, elem) {
      var n, res;
      res = this._number(str, elem);
      if (res.valid === true) {
        if (res._number === Math.floor(res._number)) {
          return true;
        }
        return {
          error_message_type: "integer_float"
        };
      }
      str = res._string;
      n = Math.floor(res._number);
      if (isNaN(n) || !isFinite(n) || str !== ("" + n)) {
        return {
          error_message_type: "integer"
        };
      }
      res.error_message_type = res.error_message_type.replace("number_", "integer_");
      return res;
    },
    number: function(str, elem) {
      var res;
      res = this._number(str, elem);
      if (res.valid === true) {
        return true;
      }
      return res;
    },
    phone: function(str, elem) {
      str = str.replace(/[\s+\+\-\/\(\)]/g, "");
      while (str[0] === "0") {
        str = str.slice(1);
      }
      if (str !== ("" + (parseInt(str, 10)))) {
        return {
          error_message_type: "phone"
        };
      }
      return true;
    },
    text: function(str, elem) {
      return str.length > 0;
    },
    radio: function(str, elem) {
      return $("[name='" + elem.attr("name") + "']:checked").length > 0;
    },
    checkbox: function(str, elem) {
      return elem.prop("checked") === true;
    },
    select: function(str, elem) {
      return this.text(elem.val());
    }
  };

  constraint_validators = {
    blacklist: function(value, blacklist) {
      var char, l, len;
      for (l = 0, len = value.length; l < len; l++) {
        char = value[l];
        if (blacklist.indexOf(char) >= 0) {
          return false;
        }
      }
      return true;
    },
    max: function(value, max, options) {
      if ((options != null ? options.include_max : void 0) === "false") {
        return value < max;
      }
      return value <= max;
    },
    max_length: function(value, max_length) {
      return value.length <= max_length;
    },
    min: function(value, min, options) {
      if ((options != null ? options.include_min : void 0) === "false") {
        return value > min;
      }
      return value >= min;
    },
    min_length: function(value, min_length) {
      return value.length >= min_length;
    },
    regex: function(value, regex, options) {
      return (new RegExp(regex, options.flags)).test(value);
    },
    whitelist: function(value, whitelist) {
      var char, l, len;
      for (l = 0, len = whitelist.length; l < len; l++) {
        char = whitelist[l];
        if (value.indexOf(char) < 0) {
          return false;
        }
      }
      return true;
    }
  };

  constraint_validator_groups = [];

  constraint_validator_options_in_locale_key = {
    include_max: true,
    include_min: true,
    enforce_max_length: true,
    enforce_min_length: true
  };

  include_constraint_option_in_locale_key = function(option, value, locale) {
    if (value != null) {
      if (!(constraint_validator_options_in_locale_key[option] instanceof Function)) {
        return ("" + constraint_validator_options_in_locale_key[option]) === ("" + value);
      }
      return ("" + (constraint_validator_options_in_locale_key[option](locale))) === ("" + value);
    }
    return false;
  };

  locales = {
    de: {
      and: "und",
      gt: "größer als",
      gte: "größer als oder gleich",
      lt: "kleiner als",
      lte: "kleiner als oder gleich"
    },
    en: {
      and: "and",
      gt: "greater than",
      gte: "greater than or equal to",
      lt: "less than",
      lte: "less than or equal to"
    }
  };

  $.extend(locales.de, {
    dependency_general: "Die Abhängigkeiten dieses Felds müssen zuerst korrekt ausgefüllt wurden",
    dependency_prefix: "Die Felder",
    dependency_suffix: "müssen noch korrekt ausgefüllt werden",
    dependency_singular_prefix: "Das Feld",
    dependency_singular_suffix: "muss noch korrekt ausgefüllt werden",
    value_email: "'{{value}}' muss die Form 'meine.adresse@anbieter.endung' haben",
    value_email_at: "'{{value}}' muss ein @-Zeichen enthalten",
    value_email_many_at: "'{{value}}' darf höchstens ein @-Zeichen enthalten",
    value_email_dot: "'{{value}}' muss eine korrekte Endung haben (z.B. '.de')",
    value_integer: "'{{value}}' muss eine Zahl sein",
    value_integer_float: "'{{value}}' darf keine Kommazahl sein",
    value_number: "'{{value}}' muss eine Zahl sein",
    value_phone: "'{{value}}' darf nur aus Zahlen, Leerzeichen und den Zeichen '+-/()' bestehen",
    value_radio: "Eins der Optionsfelder muss ausgewählt werden",
    value_checkbox: "Das Kontrollkästchen muss ausgewählt werden",
    value_select: "Es muss eine andere Option ausgewählt werden",
    value_text: "Das Textfeld muss ausgefüllt werden",
    constraint_enumerate_prefix: "'{{value}}'",
    constraint_list_prefix: "'{{value}}'",
    constraint_sentence_prefix: "'{{value}}'",
    constraint_blacklist_prefix: "darf",
    constraint_blacklist: "keines der Zeichen '{{blacklist}}'",
    constraint_blacklist_suffix: "enthalten",
    constraint_whitelist_prefix: "muss",
    constraint_whitelist: "jedes der Zeichen '{{whitelist}}'",
    constraint_whitelist_suffix: "enthalten",
    constraint_max_prefix: "darf",
    constraint_max: "nicht größer als oder gleich {{max}}",
    constraint_max_suffix: "sein",
    constraint_max_include_max_prefix: "darf",
    constraint_max_include_max: "nicht größer als {{max}}",
    constraint_max_include_max_suffix: "sein",
    constraint_max_length_prefix: "darf",
    constraint_max_length: "nicht länger als {{max_length}} Zeichen",
    constraint_max_length_suffix: "sein",
    constraint_max_length_enforce_max_length_prefix: "wurde",
    constraint_max_length_enforce_max_length: "auf {{max_length}} Zeichen",
    constraint_max_length_enforce_max_length_suffix: "gekürzt",
    constraint_min_prefix: "darf",
    constraint_min: "nicht kleiner als oder gleich {{min}}",
    constraint_min_suffix: "sein",
    constraint_min_include_min_prefix: "darf",
    constraint_min_include_min: "nicht kleiner als {{min}}",
    constraint_min_include_min_suffix: "sein",
    constraint_min_length_prefix: "darf",
    constraint_min_length: "nicht kürzer als {{min_length}} Zeichen",
    constraint_min_length_suffix: "sein",
    constraint_min_length_enforce_min_length_prefix: "wurde",
    constraint_min_length_enforce_min_length: "auf {{min_length}} Zeichen",
    constraint_min_length_enforce_min_length_suffix: "verlängert",
    constraint_regex_prefix: "muss",
    constraint_regex: "dem regulären Ausdruck '{{regex}}'",
    constraint_regex_suffix: "entsprechen"
  });

  $.extend(locales.en, {
    dependency_general: "This field's dependencies must be correctly filled in first",
    dependency_prefix: "The fields",
    dependency_suffix: "must be filled in correctly",
    dependency_singular_prefix: "The field",
    dependency_singular_suffix: "must be filled in correctly",
    value_email: "'{{value}}' address must be of the form 'my.address@provider.ending'",
    value_email_at: "'{{value}}' address must contain an @ symbol",
    value_email_many_at: "'{{value}}' address can only have one @ symbol",
    value_email_dot: "'{{value}}' must have a correct ending (i.e. '.com')",
    value_integer: "'{{value}}' must be an integer",
    value_integer_float: "'{{value}}' must not be decimal",
    value_number: "'{{value}}' must be a number",
    value_phone: "'{{value}}' can only contain numbers, spaces, and the characters '+-/()'",
    value_radio: "One of the radio buttons must be selected",
    value_checkbox: "The checkbox must be selected",
    value_select: "Another option must be selected",
    value_text: "Please fill in this text field",
    constraint_enumerate_prefix: "'{{value}}'",
    constraint_list_prefix: "'{{value}}'",
    constraint_sentence_prefix: "'{{value}}'",
    constraint_blacklist_prefix: "must not",
    constraint_blacklist: "contain any of the characters '{{blacklist}}'",
    constraint_blacklist_suffix: "",
    constraint_whitelist_prefix: "must",
    constraint_whitelist: "contain all of the characters '{{whitelist}}'",
    constraint_whitelist_suffix: "",
    constraint_max_prefix: "must not",
    constraint_max: "be greater than or equal to {{max}}",
    constraint_max_suffix: "",
    constraint_max_include_max_prefix: "must not",
    constraint_max_include_max: "be greater than {{max}}",
    constraint_max_include_max_suffix: "",
    constraint_max_length_prefix: "must not",
    constraint_max_length: "be longer than {{max_length}} characters",
    constraint_max_length_suffix: "",
    constraint_max_length_enforce_max_length_prefix: "was",
    constraint_max_length_enforce_max_length: "shortened to {{max_length}} characters",
    constraint_max_length_enforce_max_length_suffix: "",
    constraint_min_prefix: "must not",
    constraint_min: "be less than or equal to {{min}}",
    constraint_min_suffix: "",
    constraint_min_include_min_prefix: "must not",
    constraint_min_include_min: "be less than {{min}}",
    constraint_min_include_min_suffix: "",
    constraint_min_length_prefix: "must not",
    constraint_min_length: "be shorter than {{min_length}} characters",
    constraint_min_length_suffix: "",
    constraint_min_length_enforce_min_length_prefix: "was",
    constraint_min_length_enforce_min_length: "extended to {{min_length}} characters",
    constraint_min_length_enforce_min_length_suffix: "",
    constraint_regex_prefix: "must",
    constraint_regex: "match the regular expression '{{regex}}'",
    constraint_regex_suffix: ""
  });

  locale_message_builders = {
    de: {},
    en: {}
  };

  locale_message_builders.de[BUILD_MODES.ENUMERATE] = null;

  locale_message_builders.de[BUILD_MODES.SENTENCE] = null;

  locale_message_builders.de[BUILD_MODES.LIST] = null;

  locale_message_builders.en[BUILD_MODES.ENUMERATE] = null;

  locale_message_builders.en[BUILD_MODES.SENTENCE] = null;

  locale_message_builders.en[BUILD_MODES.LIST] = null;

  message_builders = {};

  message_data_creators = {};

  Maker = (function() {
    function Maker(namespace, key, func) {
      if (arguments.length === 3) {
        this.func = func;
        namespace[key] = this;
      } else {
        this.func = arguments[0];
      }
    }

    Maker.prototype.make = function() {
      return this.func.apply(this, arguments);
    };

    return Maker;

  })();

  MessageDataCreator = (function(superClass) {
    extend(MessageDataCreator, superClass);

    function MessageDataCreator(name, func) {
      MessageDataCreator.__super__.constructor.call(this, message_data_creators, name, func);
    }

    MessageDataCreator.prototype.create_data = function(errors, phase, build_mode, locale) {
      return this.make(errors, phase, build_mode, locale);
    };

    return MessageDataCreator;

  })(Maker);

  MessageBuilder = (function(superClass) {
    extend(MessageBuilder, superClass);

    function MessageBuilder(name, func) {
      MessageBuilder.__super__.constructor.call(this, message_builders, name, func);
    }

    MessageBuilder.prototype.build_message = function(parts, locale, phase, build_mode, error_data) {
      return this.make(parts, locale, phase, build_mode, error_data);
    };

    return MessageBuilder;

  })(Maker);

  OrderedDict = (function() {
    function OrderedDict() {
      this._dict = {};
      this._order = [];
    }

    OrderedDict.prototype.put = function(key, val, idx) {
      var i;
      this._dict[key] = val;
      if (idx == null) {
        if (indexOf.call(this._order, key) < 0) {
          this._order.push(key);
        }
      } else {
        i = this._order.indexOf(key);
        if (i >= 0) {
          this._order.splice(i, 1);
        }
        this._order.splice(idx, 0, key);
      }
      return this;
    };

    OrderedDict.prototype.get = function(key) {
      return this._dict[key];
    };

    OrderedDict.prototype.remove = function(key) {
      var item;
      delete this._dict[key];
      this._order = (function() {
        var l, len, ref, results1;
        ref = this._order;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          item = ref[l];
          if (item !== key) {
            results1.push(item);
          }
        }
        return results1;
      }).call(this);
      return this;
    };

    OrderedDict.prototype.join = function(str) {
      var key;
      if (str == null) {
        str = "";
      }
      return ((function() {
        var base, l, len, ref, results1;
        ref = this._order;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          key = ref[l];
          results1.push((typeof (base = this._dict[key]).join === "function" ? base.join(str) : void 0) || this._dict[key]);
        }
        return results1;
      }).call(this)).join(str);
    };

    OrderedDict.prototype.each = function(callback) {
      var i, key, l, len, ref;
      ref = this._order;
      for (i = l = 0, len = ref.length; l < len; i = ++l) {
        key = ref[i];
        if (callback.call(this, key, this._dict[key], i) === false) {
          return this;
        }
      }
      return this;
    };

    OrderedDict.prototype.to_array = function() {
      var key;
      return (function() {
        var l, len, ref, results1;
        ref = this._order;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          key = ref[l];
          results1.push(this._dict[key]);
        }
        return results1;
      }).call(this);
    };

    OrderedDict.prototype.to_object = function() {
      var key, ref, res, val;
      res = {};
      ref = this._dict;
      for (key in ref) {
        val = ref[key];
        res[key] = val;
      }
      return res;
    };

    OrderedDict.prototype.get_object = function() {
      return this._dict;
    };

    OrderedDict.prototype.get_order = function() {
      return this._order;
    };

    return OrderedDict;

  })();

  part_evaluator = function() {
    var key, part, regex, substr, val, values;
    part = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (values.length === 1) {
      values = values[0];
    } else {
      values = $.extend.apply($, values);
    }
    if (typeof part === "string") {
      for (key in values) {
        val = values[key];
        substr = "{{" + key + "}}";
        if (part.indexOf(substr) >= 0) {
          regex = new RegExp(substr, "g");
          part = part.replace(regex, val);
        }
      }
      return part;
    }
    if (part instanceof Function) {
      return part(values);
    }
    throw new Error("FormValidator: Error while building an error message. Expected mustache-like string or function but was given:", part, values);
  };

  new MessageDataCreator(VALIDATION_PHASES.DEPENDENCIES, function(errors, phase, build_mode, locale) {
    var error, key, lang_data, name, names, parts, prefix_key, suffix_key;
    names = (function() {
      var l, len, results1;
      results1 = [];
      for (l = 0, len = errors.length; l < len; l++) {
        error = errors[l];
        if (error.name != null) {
          results1.push(error.name);
        }
      }
      return results1;
    })();
    if (names.length === errors.length) {
      lang_data = locales[locale];
      key = VALIDATION_PHASES_SINGULAR[phase].toLowerCase();
      if (names.length === 1) {
        key += "_singular";
      }
      prefix_key = key + "_prefix";
      suffix_key = key + "_suffix";
      parts = (function() {
        var l, len, results1;
        results1 = [];
        for (l = 0, len = names.length; l < len; l++) {
          name = names[l];
          results1.push({
            message: "'" + name + "'",
            prefix: lang_data[prefix_key],
            suffix: lang_data[suffix_key]
          });
        }
        return results1;
      })();
    } else {
      key = (VALIDATION_PHASES_SINGULAR[phase].toLowerCase()) + "_general";
      parts = [];
    }
    return {
      parts: parts
    };
  });

  new MessageDataCreator(VALIDATION_PHASES.VALUE, function(errors, phase, build_mode, locale) {
    var error, key, part;
    error = errors[0];
    key = (VALIDATION_PHASES_SINGULAR[phase].toLowerCase()) + "_" + (error.error_message_type || error.type);
    part = {
      message: part_evaluator(locales[locale][key], error),
      prefix: "",
      suffix: ""
    };
    return {
      key: key,
      parts: [part]
    };
  });

  new MessageDataCreator(VALIDATION_PHASES.CONSTRAINTS, function(errors, phase, build_mode, locale) {
    var default_prefix, default_suffix, error, error_data, error_in_group, group, grouped_errors, i, key, key_prefix, keys, l, len, len1, len2, len3, len4, m, o, option, parts, phase_singular, prefix, q, ref, ref1, t, ungrouped_errors, val;
    parts = [];
    grouped_errors = [];
    ungrouped_errors = [];
    for (l = 0, len = errors.length; l < len; l++) {
      error = errors[l];
      error_in_group = false;
      for (i = m = 0, len1 = constraint_validator_groups.length; m < len1; i = ++m) {
        group = constraint_validator_groups[i];
        if (ref = error.type, indexOf.call(group, ref) >= 0) {
          error_in_group = true;
          if (grouped_errors[i] != null) {
            grouped_errors[i].push(error);
          } else {
            grouped_errors[i] = [error];
          }
        }
      }
      if (!error_in_group) {
        ungrouped_errors.push(error);
      }
    }
    for (o = 0, len2 = ungrouped_errors.length; o < len2; o++) {
      error = ungrouped_errors[o];
      grouped_errors.push([error]);
    }
    phase_singular = VALIDATION_PHASES_SINGULAR[phase].toLowerCase();
    key_prefix = phase_singular + "_";
    default_prefix = locales[locale][(phase_singular + "_" + build_mode + "_prefix").toLowerCase()] || "";
    default_suffix = locales[locale][(phase_singular + "_" + build_mode + "_suffix").toLowerCase()] || "";
    for (q = 0, len3 = grouped_errors.length; q < len3; q++) {
      errors = grouped_errors[q];
      if (!(errors != null)) {
        continue;
      }
      keys = [];
      for (t = 0, len4 = errors.length; t < len4; t++) {
        error = errors[t];
        keys.push(error.type);
        if (error.options != null) {
          ref1 = error.options;
          for (option in ref1) {
            val = ref1[option];
            if (include_constraint_option_in_locale_key(option, val, locale)) {
              keys.push(option);
            }
          }
        }
      }
      key = get_combined_key(keys, locale, key_prefix);
      if (key != null) {
        parts.push({
          message: part_evaluator.apply(null, [locales[locale][key]].concat(slice.call(errors))),
          prefix: part_evaluator(locales[locale][key + "_prefix"], error) || default_prefix,
          suffix: part_evaluator(locales[locale][key + "_suffix"], error) || default_suffix
        });
      } else if (DEBUG) {
        throw new Error("Could not find a translation for key while trying to create an error message during the constraint validation phase. The keys that were retrieved from the generated errors are: " + (JSON.stringify(keys)) + ". Define an according key in the 'locales' variable (e.g. '" + key_prefix + (keys.join("_")) + "')!");
      }
    }
    key = phase_singular + "_" + (build_mode.toLowerCase());
    prefix = part_evaluator("" + locales[locale][key + "_prefix"], errors[0]);
    error_data = $.extend.apply($, [{}].concat(errors));
    return {
      key: key,
      parts: parts,
      error_data: error_data,
      prefix: prefix
    };
  });

  message_builder_helper = new Maker(function(data, phase, build_mode, locale, prefix, suffix, prefix_delimiter, suffix_delimiter) {
    var dict, error_data, i, key, l, len, len1, m, new_parts, part, parts, ref;
    if (prefix_delimiter == null) {
      prefix_delimiter = " ";
    }
    if (suffix_delimiter == null) {
      suffix_delimiter = " ";
    }
    key = data.key, parts = data.parts, error_data = (ref = data.error_data) != null ? ref : {};
    prefix = prefix || data.prefix || locales[locale][key + "_prefix"] || "";
    suffix = suffix || data.suffix || locales[locale][key + "_suffix"] || "";
    data.prefix = (typeof prefix === "function" ? prefix() : void 0) || prefix;
    data.suffix = (typeof suffix === "function" ? suffix() : void 0) || suffix;
    for (i = l = 0, len = parts.length; l < len; i = ++l) {
      part = parts[i];
      dict = new OrderedDict();
      if (part.prefix) {
        dict.put("prefix", part.prefix);
        dict.put("prefix_delimiter", part.prefix_delimiter || prefix_delimiter);
      }
      dict.put("message", part.message);
      if (part.suffix) {
        dict.put("suffix_delimiter", part.suffix_delimiter || suffix_delimiter);
        dict.put("suffix", part.suffix);
      }
      parts[i] = dict;
    }
    new_parts = new OrderedDict();
    for (i = m = 0, len1 = parts.length; m < len1; i = ++m) {
      part = parts[i];
      new_parts.put(i, part);
    }
    data.parts = new_parts;
    return data;
  });

  new MessageBuilder(BUILD_MODES.ENUMERATE, function(data, phase, build_mode, locale) {
    var i, l, lang_data, len, len1, len2, m, new_parts, o, p, part, parts, parts_grouped_by_prefix, parts_grouped_by_suffix, prefix, prefix_group, suffix, suffix_group;
    data = message_builder_helper.make(data, phase, build_mode, locale);
    parts = data.parts.to_array();
    lang_data = locales[locale];
    parts_grouped_by_suffix = group_arr_by(parts, function(part) {
      return part.get("suffix") || "";
    });
    parts = [];
    for (suffix in parts_grouped_by_suffix) {
      suffix_group = parts_grouped_by_suffix[suffix];
      parts_grouped_by_prefix = group_arr_by(suffix_group, function(part) {
        return part.get("prefix") || "";
      });
      for (prefix in parts_grouped_by_prefix) {
        prefix_group = parts_grouped_by_prefix[prefix];
        for (i = l = 0, len = prefix_group.length; l < len; i = ++l) {
          p = prefix_group[i];
          if (!(i > 0)) {
            continue;
          }
          p.remove("prefix");
          p.remove("prefix_delimiter");
        }
      }
      for (i = m = 0, len1 = suffix_group.length; m < len1; i = ++m) {
        p = suffix_group[i];
        if (!(i < suffix_group.length - 1)) {
          continue;
        }
        p.remove("suffix_delimiter");
        p.remove("suffix");
      }
      parts = parts.concat(suffix_group);
    }
    new_parts = new OrderedDict();
    for (i = o = 0, len2 = parts.length; o < len2; i = ++o) {
      part = parts[i];
      if (i === parts.length - 1 && i > 0) {
        part.put("prefix", " " + locales[locale]["and"] + " " + (part.get("prefix") || ""), 0);
        part.put("prefix_delimiter", " ", 1);
      }
      new_parts.put(i, part);
    }
    data.parts = new_parts;
    return ((data.prefix || "") + " " + (new_parts.join("")) + " " + (data.suffix || "")).replace(/\s+/g, " ");
  });

  new MessageBuilder(BUILD_MODES.SENTENCE, function(data, phase, build_mode, locale) {
    var l, len, part, parts, ref;
    data = message_builder_helper.make(data, phase, build_mode, locale);
    data.parts.each(function(idx, part) {
      part.put("prefix", (" " + (data.prefix || "") + " " + (part.get("prefix") || "")).trim(), 0);
      part.put("prefix_delimiter", " ", 1);
      part.put("suffix_delimiter", (part.get("suffix") ? part.get("suffix_delimiter") : ""), 3);
      part.put("suffix", (" " + (data.suffix || "") + " " + (part.get("suffix") || "") + ".").trim(), 4);
      return true;
    });
    parts = [];
    ref = data.parts.to_array();
    for (l = 0, len = ref.length; l < len; l++) {
      part = ref[l];
      parts.push(part.join());
    }
    return parts.join(" ").replace(/\s+/g, " ").trim();
  });

  new MessageBuilder(BUILD_MODES.LIST, function(data, phase, build_mode, locale) {
    var sentence, sentences;
    sentences = message_builders[BUILD_MODES.SENTENCE].build_message(data, phase, build_mode, locale);
    if (sentences[sentences.length - 1] === ".") {
      sentences += " ";
    }
    return "<ul><li>" + (((function() {
      var l, len, ref, results1;
      ref = sentences.split(". ");
      results1 = [];
      for (l = 0, len = ref.length; l < len; l++) {
        sentence = ref[l];
        if (sentence) {
          results1.push(sentence + ".");
        }
      }
      return results1;
    })()).join("</li><li>")) + "</li></ul>";
  });

  dependency_change_actions = {};

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.DISPLAY] = function(element, valid) {
    var orig_display;
    if (!valid) {
      element.data("_fv_orig_display", element.css("display"));
      element.css("display", "none");
    } else {
      if ((orig_display = element.data("_fv_orig_display")) != null) {
        element.css("display", orig_display);
      }
    }
    return element;
  };

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.ENABLE] = function(element, valid) {
    return element.prop("disabled", !valid);
  };

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.FADE] = function(element, valid) {
    if (valid) {
      element.fadeIn(DEPENDENCY_CHANGE_ACTION_DURATION);
    } else {
      element.fadeOut(DEPENDENCY_CHANGE_ACTION_DURATION);
    }
    return element;
  };

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.OPACITY] = function(element, valid) {
    var orig_opacity;
    if (!valid) {
      element.data("_fv_orig_opacity", element.css("opacity"));
      element.animate({
        opacity: 0,
        DEPENDENCY_CHANGE_ACTION_DURATION: DEPENDENCY_CHANGE_ACTION_DURATION
      });
    } else {
      if ((orig_opacity = element.data("_fv_orig_opacity")) != null) {
        element.animate({
          opacity: orig_opacity,
          DEPENDENCY_CHANGE_ACTION_DURATION: DEPENDENCY_CHANGE_ACTION_DURATION
        });
      }
    }
    return element;
  };

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.SHOW] = function(element, valid) {
    if (valid) {
      element.show(DEPENDENCY_CHANGE_ACTION_DURATION);
    } else {
      element.hide(DEPENDENCY_CHANGE_ACTION_DURATION);
    }
    return element;
  };

  dependency_change_actions[DEPENDENCY_CHANGE_ACTIONS.SLIDE] = function(element, valid) {
    if (valid) {
      element.slideDown(DEPENDENCY_CHANGE_ACTION_DURATION);
    } else {
      element.slideUp(DEPENDENCY_CHANGE_ACTION_DURATION);
    }
    return element;
  };

  FormModifier = (function() {
    function FormModifier(form_validator, options) {
      this.form_validator = form_validator;
      if ((ERROR_OUTPUT_MODES[options.error_output_mode] != null) || options.error_output_mode instanceof Function) {
        this.error_output_mode = options.error_output_mode;
      } else {
        this.error_output_mode = ERROR_OUTPUT_MODES.DEFAULT;
      }
    }

    FormModifier.prototype._apply_classes = function(element, error_targets, classes, is_valid) {
      var i, l, len, target, targets;
      if (error_targets != null) {
        targets = this.form_validator._find_targets(error_targets, element);
        for (i = l = 0, len = targets.length; l < len; i = ++l) {
          target = targets[i];
          if (!(target instanceof jQuery)) {
            target = targets.eq(i);
          }
          if (is_valid === false) {
            target.addClass(classes);
          } else {
            target.removeClass(classes);
          }
        }
        return targets;
      }
      return [];
    };

    FormModifier.prototype._set_message_below = function(message, element, data) {
      var target;
      if ((target = element.data("_fv_error_container")) == null) {
        if (data.type === "radio") {
          element = $("input[name='" + (element.attr("name")) + "']").last();
        }
        if ((target = element.next(".fv-error-message")).length === 0) {
          target = $("<div class=\"fv-error-message\" />");
          element.after(target);
        }
        element.data("_fv_error_container", target);
      }
      target.html(message);
      return this;
    };

    FormModifier.prototype._set_message_tooltip = function(message, element, data) {
      if (element.data("_fv_tooltip") == null) {
        element.tooltip({
          html: true,
          placement: element.attr("data-placement") || "top",
          title: function() {
            return $(this).data("_fv_tooltip");
          }
        });
      }
      element.data("_fv_tooltip", message).tooltip("hide");
      return this;
    };

    FormModifier.prototype._set_message_popover = function(message, element, data) {
      if (data.type === "checkbox" || data.type === "radio" || data.type === "select") {
        element.attr("title", message);
        return this;
      }
      if (element.data("_fv_popover") == null) {
        element.popover({
          html: true,
          placement: element.attr("data-placement") || "right",
          content: function() {
            return $(this).data("_fv_popover");
          },
          trigger: "manual"
        }).focus(function() {
          element.popover("show");
          return false;
        }).blur(function() {
          element.popover("hide");
          return true;
        }).click(function() {
          if (document.activeElement === this) {
            element.popover("toggle");
          }
          return true;
        });
      }
      element.data("_fv_popover", message).popover("hide");
      return this;
    };

    FormModifier.prototype._process_error_message = function(message, element, data) {
      var error_output_mode, target;
      if (this.error_output_mode === ERROR_OUTPUT_MODES.NONE) {
        return this;
      }
      if (this.error_output_mode instanceof Function) {
        target = this.error_output_mode(element, data, message);
        target.html(message);
      } else {
        error_output_mode = this.error_output_mode.toLowerCase();
        this["_set_message_" + error_output_mode](message, element, data);
      }
      return this;
    };

    FormModifier.prototype._process_max_length = function(constraint, element, data) {
      var length, val;
      if (constraint.options.enforce_max_length === "true") {
        length = parseInt(constraint.value, 10);
        val = data.value.slice(0, length);
        data.value = val;
        element.val(val);
        return true;
      }
      return false;
    };

    FormModifier.prototype._process_min_length = function(constraint, element, data) {
      var i, length, val;
      if (constraint.options.enforce_min_length === "true") {
        length = parseInt(constraint.value, 10);
        val = data.value + ((function() {
          var l, ref, results1;
          results1 = [];
          for (i = l = 0, ref = data.value.length - length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
            results1.push(".");
          }
          return results1;
        })()).join("");
        data.value = val;
        element.val(val);
        return true;
      }
      return false;
    };

    FormModifier.prototype._process_constraint = function(constraint, element, data) {
      var name1;
      return (typeof this[name1 = "_process_" + constraint.name] === "function" ? this[name1](constraint, element, data) : void 0) || false;
    };

    FormModifier.prototype._on_dependency_change = function(action, element, data, valid) {
      var CLASS, ref;
      CLASS = FormValidator;
      if (data.depends_on.length > 0 && (data.error_targets != null)) {
        if (!(this.form_validator.dependency_change_action instanceof Function)) {
          if ((ref = CLASS.dependency_change_actions[action]) != null) {
            ref.call(CLASS.dependency_change_actions, data.error_targets, valid);
          }
        } else {
          this.form_validator.dependency_change_action(element, valid);
        }
      }
      return this;
    };

    FormModifier.prototype.modify = function(grouped_errors, options) {
      var constraint, data, data_has_changed, elem, err, error, error_output_mode, fields, first_invalid_element, form_validator, grouped_error, i, is_valid, l, len, len1, len2, m, message, o, q, ref, ref1, ref2, valid_dependencies;
      form_validator = this.form_validator;
      fields = form_validator.fields.all;
      error_output_mode = form_validator.error_output_mode;
      first_invalid_element = null;
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = form_validator._get_element_data(elem);
        grouped_error = null;
        for (m = 0, len = grouped_errors.length; m < len; m++) {
          err = grouped_errors[m];
          if (!(err.element.is(elem))) {
            continue;
          }
          grouped_error = err;
          break;
        }
        if (grouped_error == null) {
          is_valid = true;
          message = "";
        } else {
          is_valid = false;
          if (first_invalid_element == null) {
            first_invalid_element = elem;
          }
          ref1 = grouped_error.errors;
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            error = ref1[o];
            if (error.phase === VALIDATION_PHASES.DEPENDENCIES) {
              valid_dependencies = false;
            } else if (error.phase === VALIDATION_PHASES.CONSTRAINTS) {
              ref2 = data.constraints;
              for (q = 0, len2 = ref2.length; q < len2; q++) {
                constraint = ref2[q];
                if (!(constraint.name === error.type)) {
                  continue;
                }
                data_has_changed = this._process_constraint(constraint, elem, data);
                if (data_has_changed) {
                  form_validator._set_element_data(elem, data);
                }
                break;
              }
            }
          }
          message = grouped_error.message;
        }
        if (data.dependency_changed) {
          this._on_dependency_change(data.dependency_change_action, elem, data, data.valid_dependencies);
        }
        if (options.apply_error_classes === true) {
          this._apply_classes(elem, data.error_targets, data.error_classes || form_validator.error_classes, is_valid);
          this._apply_classes(elem, data.error_targets, data.success_classes || form_validator.success_classes, !is_valid);
          this._apply_classes(elem, data.depends_on, data.dependency_error_classes || form_validator.dependency_error_classes, data.valid_dependencies);
        }
        this._process_error_message(message, elem, data);
      }
      if (options.focus_invalid === true) {
        if (first_invalid_element != null) {
          first_invalid_element.focus();
        }
      }
      return this;
    };

    return FormModifier;

  })();

  window.FormValidator = (function() {
    var constant, name;

    for (name in EXPOSED_CONSTANTS) {
      constant = EXPOSED_CONSTANTS[name];
      FormValidator[name] = constant;
    }

    FormValidator.constraint_validators = constraint_validators;

    FormValidator.validators = validators;

    FormValidator.dependency_change_actions = dependency_change_actions;

    FormValidator.locales = locales;

    FormValidator.default_preprocessors = {
      number: function(str, elem, locale) {
        switch (locale) {
          case "de":
            return str.replace(/\,/g, ".");
          default:
            return str;
        }
      },
      integer: function(str, elem, locale) {
        switch (locale) {
          case "de":
            return str.replace(/\,/g, ".");
          default:
            return str;
        }
      }
    };

    FormValidator.configure = function(callback) {
      callback({
        constraint_validator_groups: constraint_validator_groups,
        constraint_validator_options_in_locale_key: constraint_validator_options_in_locale_key,
        constraint_validator_options: constraint_validator_options,
        locale_message_builders: locale_message_builders,
        message_builders: message_builders,
        message_data_creators: message_data_creators
      });
      return this;
    };

    FormValidator.get_error_message_type = function(special_type, error_mode) {
      var base_type;
      if (error_mode === this.ERROR_MODES.SIMPLE) {
        base_type = special_type.split("_")[0];
        return base_type;
      }
      return special_type;
    };

    FormValidator._build_error_message = function(phase, errors, build_mode, locale) {
      var data;
      data = message_data_creators[phase].create_data(errors, phase, build_mode, locale);
      return message_builders[build_mode].build_message(data, phase, build_mode, locale);
    };

    FormValidator.get_error_message_for_element = function(element, errors, build_mode, locale, delimiter) {
      var error, error_message_parts, grouped_errors, l, len, phase, ref;
      if (delimiter == null) {
        delimiter = " ";
      }
      error_message_parts = [];
      grouped_errors = {};
      for (phase in VALIDATION_PHASES) {
        grouped_errors[phase] = (function() {
          var l, len, results1;
          results1 = [];
          for (l = 0, len = errors.length; l < len; l++) {
            error = errors[l];
            if (error.phase === phase) {
              results1.push(error);
            }
          }
          return results1;
        })();
      }
      ref = this.ERROR_MESSAGE_CONFIG.PHASE_ORDER;
      for (l = 0, len = ref.length; l < len; l++) {
        phase = ref[l];
        if (grouped_errors[phase].length > 0) {
          error_message_parts.push(this._build_error_message(phase, grouped_errors[phase], build_mode, locale));
        }
      }
      return error_message_parts.join(delimiter);
    };

    FormValidator["new"] = function(form, options) {
      var form_modifier, form_validator;
      if (DEBUG && !(form instanceof jQuery)) {
        throw new Error("FormValidator::constructor: Invalid form given (must be a jQuery object)!");
      }
      form_validator = new this(form, null, options);
      form_modifier = new FormModifier(form_validator, options);
      form_validator.form_modifier = form_modifier;
      return form_validator;
    };

    FormValidator.new_without_modifier = function(form, options) {
      if (DEBUG && !(form instanceof jQuery)) {
        throw new Error("FormValidator::constructor: Invalid form given (must be a jQuery object)!");
      }
      return new this(form, null, options);
    };


    /**
    * @param form {Form}
    * @param options {Object}
    *
     */

    function FormValidator(form, form_modifier, options) {
      var CLASS;
      if (options == null) {
        options = {};
      }
      CLASS = this.constructor;
      this.form = form;
      this.fields = null;
      this.form_modifier = form_modifier;
      this.last_validation = null;
      this.error_classes = options.error_classes || this.form.attr("data-fv-error-classes") || "fv-invalid";
      this.success_classes = options.success_classes || this.form.attr("data-fv-success-classes") || "fv-valid";
      this.dependency_error_classes = options.dependency_error_classes || this.form.attr("data-fv-dependency-error-classes") || "fv-invalid-dependency";
      this.dependency_change_action = options.dependency_change_action || this.form.attr("data-fv-dependency-change-action") || DEPENDENCY_CHANGE_ACTION.DEFAULT;
      this.validators = $.extend({}, CLASS.validators, options.validators);
      this.validation_options = options.validation_options || null;
      this.constraint_validators = $.extend({}, CLASS.constraint_validators, options.constraint_validators);
      this.build_mode = options.build_mode || BUILD_MODES.DEFAULT;
      this.error_mode = CLASS.ERROR_MODES[options.error_mode] != null ? options.error_mode : CLASS.ERROR_MODES.DEFAULT;
      this.locale = options.locale || "en";
      this.error_target_getter = options.error_target_getter || null;
      this.field_getter = options.field_getter || null;
      this.required_field_getter = options.required_field_getter || null;
      this.create_dependency_error_message = options.create_dependency_error_message || null;
      this.preprocessors = $.extend(CLASS.default_preprocessors, options.preprocessors || {});
      this.postprocessors = options.postprocessors || {};
      this.group = options.group || null;
      this.process_errors = options.process_errors || null;
      this._field_order = null;
    }

    FormValidator.prototype._get_fields = function(form) {
      return (typeof this.field_getter === "function" ? this.field_getter(form) : void 0) || form.find("[data-fv-validate]").filter(function(idx, elem) {
        return $(elem).closest("[data-fv-ignore-children]").length === 0;
      });
    };

    FormValidator.prototype._get_required = function(fields) {
      return (typeof this.required_field_getter === "function" ? this.required_field_getter(fields) : void 0) || fields.not("[data-fv-optional='true']");
    };

    FormValidator.prototype._get_attribute_value_for_key = function(element, key) {
      var attribute, boolean, has_attr, k, prefix, ref, special, value;
      prefix = "data-fv-";
      special = {
        type: "validate",
        required: "optional"
      };
      boolean = ["preprocess", "required"];
      if (special[key] == null) {
        attribute = prefix + key.replace(/\_/g, "-");
      } else {
        attribute = prefix + special[key];
      }
      value = element.attr(attribute);
      has_attr = (value != null);
      if (has_attr) {
        value = value.trim();
      } else {
        if (ref = (k = key.toUpperCase()), indexOf.call(Object.keys(DEFAULT_ATTR_VALUES), ref) >= 0) {
          value = DEFAULT_ATTR_VALUES[k];
        }
      }
      if (indexOf.call(boolean, key) >= 0) {
        value = value === "true" || value === true ? true : false;
      }
      if (key === "required" && has_attr) {
        value = !value;
      }
      return value;
    };

    FormValidator.prototype._set_element_data = function(element, data) {
      $.data(element[0], "_fv", data);
      return this;
    };

    FormValidator.prototype._get_element_data = function(element) {
      return $.data(element[0], "_fv");
    };

    FormValidator.prototype._cache_attribute = function(element, data, key, value) {
      if (value == null) {
        value = element.attr("data-fv-" + (key.replace(/\_/g, "-")));
      } else if (value instanceof Function) {
        value = value.call(this);
      }
      if (value == null) {
        value = DEFAULT_ATTR_VALUES[key.toUpperCase()];
      }
      data[key] = value;
      return data;
    };

    FormValidator.prototype._get_value_info = function(element, data) {
      var original_value, preprocess, type, usedValFunc, value, value_has_changed;
      type = data.type, preprocess = data.preprocess;
      usedValFunc = true;
      value = element.val();
      if (value == null) {
        usedValFunc = false;
        value = element.text();
      }
      original_value = value;
      value_has_changed = original_value !== data.value;
      data.value = original_value;
      if ((this.preprocessors[type] != null) && preprocess !== false) {
        value = this.preprocessors[type].call(this.preprocessors, value, element, this.locale);
      }
      return {
        usedValFunc: usedValFunc,
        value: value,
        original_value: original_value,
        value_has_changed: value_has_changed
      };
    };

    FormValidator.prototype._find_targets = function(targets, element, delimiter) {
      var target;
      if (delimiter == null) {
        delimiter = /\;\s+/g;
      }
      if (typeof targets === "string") {
        return (function() {
          var l, len, ref, results1;
          ref = targets.split(delimiter);
          results1 = [];
          for (l = 0, len = ref.length; l < len; l++) {
            target = ref[l];
            results1.push(this._find_target(target, element));
          }
          return results1;
        }).call(this);
      }
      return targets || [];
    };

    FormValidator.prototype._find_target = function(target, element) {
      var result;
      if (target === "self") {
        return element;
      }
      result = this.form.find("[data-fv-name='" + target + "']");
      if (result.length === 0) {
        result = element.closest(target);
      }
      if (result.length === 0) {
        result = this.form.find(target);
      }
      if (result.length === 0) {
        result = $(target);
      }
      return result;
    };

    FormValidator.prototype._get_error_targets = function(element, type) {
      return (typeof this.error_target_getter === "function" ? this.error_target_getter(element, type) : void 0) || element.attr("data-fv-error-targets") || element.closest("[data-fv-error-targets]").attr("data-fv-error-targets") || DEFAULT_ATTR_VALUES.ERROR_TARGETS;
    };

    FormValidator.prototype._group = function(fields) {
      var data, dict, elem, elems, group_name, i, l, ref;
      dict = {};
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = this._get_element_data(elem);
        if (data.group == null) {
          data.group = elem.attr("data-fv-group") || data.name;
          this._set_element_data(elem, data);
        }
        group_name = data.group;
        if (dict[group_name] == null) {
          dict[group_name] = [elem];
        } else {
          dict[group_name].push(elem);
        }
      }
      return (function() {
        var results1;
        results1 = [];
        for (name in dict) {
          elems = dict[name];
          results1.push(elems);
        }
        return results1;
      })();
    };

    FormValidator.prototype._group_errors = function(errors, options) {
      var CLASS, elem, elem_errors, error, fields, grouped_by_phase, i, l, message, phase, phase_errors, ref, ref1, result;
      CLASS = this.constructor;
      result = [];
      fields = this.fields.all;
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        elem_errors = (function() {
          var len, m, results1;
          results1 = [];
          for (m = 0, len = errors.length; m < len; m++) {
            error = errors[m];
            if (error.element.is(elem)) {
              results1.push(error);
            }
          }
          return results1;
        })();
        grouped_by_phase = group_arr_by(elem_errors, function(error) {
          return error.phase;
        });
        for (phase in VALIDATION_PHASES) {
          if (!(((ref1 = (phase_errors = grouped_by_phase[phase])) != null ? ref1.length : void 0) > 0)) {
            continue;
          }
          elem_errors = phase_errors;
          break;
        }
        if (elem_errors.length > 0) {
          if (options.messages === true) {
            message = CLASS.get_error_message_for_element(elem, elem_errors, this.build_mode, this.locale);
          } else {
            message = "";
          }
          result.push({
            element: elem,
            errors: elem_errors,
            message: message
          });
        }
      }
      return result;
    };

    FormValidator.prototype._validate_value = function(element, data, value_info) {
      var type, validation, validator, value;
      type = data.type;
      value = value_info.value;
      validator = this.validators[type];
      if (validator == null) {
        throw new Error("FormValidator::_validate_value: No validator found for type '" + type + "'. Make sure the type is correct or define a validator!");
      }
      validation = validator.call(this.validators, value, element);
      if (validation === false) {
        validation = {
          error_message_type: type
        };
      } else if (typeof validation === "string") {
        validation = {
          error_message_type: validation
        };
      }
      if (validation !== true) {
        validation.error_message_type = this.constructor.get_error_message_type(validation.error_message_type, this.error_mode);
      }
      return validation;
    };

    FormValidator.prototype._validate_dependencies = function(element, data, options) {
      var dependency_data, dependency_elem, elem_errors, elements, errors, i, l, len, valid;
      errors = [];
      elements = data.depends_on;
      for (i = l = 0, len = elements.length; l < len; i = ++l) {
        dependency_elem = elements[i];
        dependency_data = this._get_element_data(dependency_elem);
        elem_errors = this._validate_element(dependency_elem, dependency_data, this._get_value_info(dependency_elem, dependency_data), options);
        if (elem_errors.length > 0) {
          errors.push({
            dependency_element: dependency_elem,
            element: element,
            index: i,
            type: dependency_data.type,
            name: dependency_data.name
          });
        }
      }
      if (data.dependency_mode == null) {
        this._cache_attribute(element, data, "dependency_mode");
        this._set_element_data(element, data);
      }
      if (data.dependency_mode === "any") {
        valid = errors.length < elements.length;
      } else {
        valid = errors.length === 0;
      }
      return {
        dependency_errors: errors,
        dependency_elements: elements,
        valid_dependencies: valid,
        dependency_mode: data.dependency_mode
      };
    };

    FormValidator.prototype._validate_constraints = function(element, data, value) {
      var CLASS, constraint, constraint_name, constraint_validator, constraint_validator_options, constraint_value, constraints, l, len, len1, m, option, options, ref, result, results;
      results = {};
      if (data.constraints != null) {
        constraints = data.constraints;
      } else {
        CLASS = this.constructor;
        constraints = [];
        ref = this.constraint_validators;
        for (constraint_name in ref) {
          constraint_validator = ref[constraint_name];
          if ((constraint_value = this._get_attribute_value_for_key(element, constraint_name)) != null) {
            if ((constraint_validator_options = CONSTRAINT_VALIDATOR_OPTIONS[constraint_name]) != null) {
              options = {};
              for (l = 0, len = constraint_validator_options.length; l < len; l++) {
                option = constraint_validator_options[l];
                options[option] = this._get_attribute_value_for_key(element, option) || DEFAULT_ATTR_VALUES[option.toUpperCase()];
              }
            } else {
              options = null;
            }
            constraints.push({
              name: constraint_name,
              options: options,
              validator: constraint_validator,
              value: constraint_value
            });
          }
        }
        data.constraints = constraints;
        this._set_element_data(element, data);
      }
      for (m = 0, len1 = constraints.length; m < len1; m++) {
        constraint = constraints[m];
        if (constraint.validator.call(this.constraint_validators, value, constraint.value, constraint.options) === true) {
          results[constraint.name] = true;
        } else {
          result = {};
          result.options = constraint.options;
          result[constraint.name] = constraint.value;
          results[constraint.name] = result;
        }
      }
      return results;
    };

    FormValidator.prototype._validate_element = function(elem, data, value_info, options) {
      var constraint_name, dependency_elements, dependency_error, dependency_errors, dependency_mode, error, errors, is_required, l, len, len1, m, original_value, phase, prev_phases_valid, ref, ref1, ref2, result, temp, type, usedValFunc, valid_dependencies, validation_res, value, value_has_changed;
      if (data.last_validation === this.last_validation) {
        return data.errors[VALIDATION_PHASES.DEPENDENCIES].concat(data.errors[VALIDATION_PHASES.VALUE], data.errors[VALIDATION_PHASES.CONSTRAINTS]);
      }
      errors = [];
      prev_phases_valid = true;
      is_required = data.required;
      type = data.type;
      value = value_info.value, original_value = value_info.original_value, value_has_changed = value_info.value_has_changed, usedValFunc = value_info.usedValFunc;
      phase = VALIDATION_PHASES.DEPENDENCIES;
      ref = this._validate_dependencies(elem, data, options), dependency_errors = ref.dependency_errors, dependency_elements = ref.dependency_elements, dependency_mode = ref.dependency_mode, valid_dependencies = ref.valid_dependencies;
      if (!valid_dependencies) {
        prev_phases_valid = false;
        for (l = 0, len = dependency_errors.length; l < len; l++) {
          dependency_error = dependency_errors[l];
          $.extend(dependency_error, {
            element: elem,
            required: is_required,
            type: "dependency",
            phase: phase,
            mode: dependency_mode
          });
        }
        data.errors[phase] = dependency_errors;
      } else {
        data.errors[phase] = [];
      }
      data.dependency_changed = valid_dependencies !== data.valid_dependencies;
      data.valid_dependencies = valid_dependencies;
      if (data.dependency_changed && (data.error_targets == null)) {
        this._cache_attribute(elem, data, "error_targets", function() {
          return this._get_error_targets(elem, type);
        });
      }
      errors = errors.concat(data.errors[phase]);
      phase = VALIDATION_PHASES.VALUE;
      if (prev_phases_valid || !options.stop_on_error) {
        if (value_has_changed || (data.dependency_changed && data.valid_dependencies && data.errors[phase].length === 0)) {
          validation_res = this._validate_value(elem, data, value_info);
          if (validation_res !== true) {
            prev_phases_valid = false;
            data.valid_value = false;
            data.errors[phase] = [
              {
                element: elem,
                error_message_type: validation_res.error_message_type,
                phase: phase,
                required: is_required,
                type: type,
                value: value
              }
            ];
          } else {
            data.valid_value = true;
            data.errors[phase] = [];
          }
        } else if (!value_has_changed) {
          if (prev_phases_valid || !options.stop_on_error) {
            if (data.valid_value !== true) {
              prev_phases_valid = false;
            }
          }
        }
      }
      errors = errors.concat(data.errors[phase]);
      phase = VALIDATION_PHASES.CONSTRAINTS;
      if (value_has_changed) {
        if (prev_phases_valid || !options.stop_on_error) {
          data.valid_constraints = true;
          temp = [];
          ref1 = this._validate_constraints(elem, data, value);
          for (constraint_name in ref1) {
            result = ref1[constraint_name];
            if (!(result !== true)) {
              continue;
            }
            data.valid_constraints = false;
            prev_phases_valid = false;
            temp.push($.extend(result, {
              element: elem,
              required: is_required,
              type: constraint_name,
              phase: phase,
              value: value
            }));
          }
          data.errors[phase] = temp;
        }
      } else {
        if (prev_phases_valid || !options.stop_on_error) {
          if (data.valid_constraints !== true) {
            prev_phases_valid = false;
          }
        }
      }
      errors = errors.concat(data.errors[phase]);
      if (data.valid_dependencies && data.valid_value && data.valid_constraints) {
        if (data.valid !== true || (data.postprocess == null) || (data.output_preprocessed == null)) {
          data.valid = true;
          this._cache_attribute(elem, data, "postprocess");
          this._cache_attribute(elem, data, "output_preprocessed");
        }
        if (data.postprocess === true || data.output_preprocessed === true) {
          if (data.postprocess === true) {
            value = (ref2 = this.postprocessors[type]) != null ? ref2.call(this.postprocessors, value, elem, this.locale) : void 0;
          } else if (data.output_preprocessed === true) {
            if (this.preprocessors[type] != null) {
              value = this.preprocessors[type].call(this.preprocessors, value, elem, this.locale);
            }
          }
          if (usedValFunc) {
            elem.val(value);
          } else {
            elem.text(value);
          }
          for (m = 0, len1 = errors.length; m < len1; m++) {
            error = errors[m];
            error.value = value;
          }
        }
      } else {
        if (data.valid !== false) {
          data.valid = false;
        }
      }
      if (options.apply_error_classes === true && (data.error_targets == null)) {
        this._cache_attribute(elem, data, "error_targets", function() {
          return this._get_error_targets(elem, type);
        });
      }
      data.last_validation = this.last_validation;
      this._set_element_data(elem, data);
      return errors;
    };

    FormValidator.prototype.register_validator = function(type, validator, error_message_types) {
      if (DEBUG) {
        if (validator.call instanceof Function && typeof (validator.call(this.validators, "", $())) === "boolean" && validator.error_message_types instanceof Array) {
          this.validators[type] = validator;
        } else {
          console.warn("FormValidator::register_validator: Invalid validator given (has no call method or not returning a boolean)!");
        }
      } else {
        this.validators[type] = validator;
      }
      return this;
    };

    FormValidator.prototype.deregister_validator = function(type) {
      delete this.validators[type];
      return this;
    };

    FormValidator.prototype.register_preprocessor = function(type, processor) {
      this.preprocessors[type] = processor;
      return this;
    };

    FormValidator.prototype.deregister_preprocessor = function(type) {
      delete this.preprocessors;
      return this;
    };

    FormValidator.prototype.register_postprocessor = function(type, processor) {
      this.postprocessors[type] = processor;
      return this;
    };

    FormValidator.prototype.deregister_postprocessor = function(type) {
      delete this.postprocessors[type];
      return this;
    };

    FormValidator.prototype.cache = function() {
      var data, dep, dependency_data, elem, fields, i, id, id_to_elem, key, l, len, len1, m, o, ref;
      fields = this._get_fields(this.form);
      dependency_data = {};
      id_to_elem = {};
      for (i = l = 0, ref = fields.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        elem = fields.eq(i);
        data = {};
        for (m = 0, len = REQUIRED_CACHE.length; m < len; m++) {
          key = REQUIRED_CACHE[m];
          data[key] = this._get_attribute_value_for_key(elem, key);
        }
        data.depends_on = this._find_targets(data.depends_on, elem, /^\s*\;\s*$/g);
        data.id = i;
        if (data.dependency_change_action == null) {
          data.dependency_change_action = this.dependency_change_action;
        }
        for (o = 0, len1 = OPTIONAL_CACHE.length; o < len1; o++) {
          key = OPTIONAL_CACHE[o];
          data[key] = null;
        }
        data.errors = {};
        data.errors[VALIDATION_PHASES.DEPENDENCIES] = [];
        data.errors[VALIDATION_PHASES.VALUE] = [];
        data.errors[VALIDATION_PHASES.CONSTRAINTS] = [];
        this._set_element_data(elem, data);
        id_to_elem[data.id] = elem;
        dependency_data[data.id] = (function() {
          var len2, q, ref1, results1;
          ref1 = data.depends_on;
          results1 = [];
          for (q = 0, len2 = ref1.length; q < len2; q++) {
            dep = ref1[q];
            results1.push(this._get_element_data(dep).id);
          }
          return results1;
        }).call(this);
      }
      this.fields = {
        all: fields,
        required: this._get_required(fields),
        ordered: (function() {
          var len2, q, ref1, results1;
          ref1 = toposort(dependency_data);
          results1 = [];
          for (q = 0, len2 = ref1.length; q < len2; q++) {
            id = ref1[q];
            results1.push(id_to_elem[id]);
          }
          return results1;
        })()
      };
      console.log("validation order:", toposort(dependency_data));
      return this;
    };


    /**
    * @method validate
    * @param options {Object}
    * Default is this.validation_option. Otherwise:
    * Valid options are:
    *  - all:                   {Boolean} (default is false)
    *    -> force validation on optional fields
    *  - apply_error_classes:   {Boolean} (default is true)
    *  - focus_invalid:         {Boolean} (default is true)
    *  - messages:              {Boolean} (default is true)
    *  - stop_on_error:         {Boolean} (default is true)
    *    -> stop the current validation after an error has been found (otherwise all errors will be collected)
    *  - recache:               {Boolean} (default is false)
    *
     */

    FormValidator.prototype.validate = function(options) {
      var CLASS, data, default_options, elem, elem_errors, errors, fields, grouped_errors, is_required, l, len, original_value, ref, type, usedValFunc, value, value_has_changed, value_info;
      if (options == null) {
        options = {};
      }
      default_options = {
        all: false,
        apply_error_classes: true,
        focus_invalid: true,
        messages: true,
        stop_on_error: true,
        recache: false
      };
      options = $.extend(default_options, this.validation_options, options);
      if ((this.fields == null) || options.recache === true) {
        this.cache();
      }
      this.last_validation = Date.now();
      CLASS = this.constructor;
      errors = [];
      usedValFunc = false;
      fields = this.fields.ordered;
      for (l = 0, len = fields.length; l < len; l++) {
        elem = fields[l];
        data = this._get_element_data(elem);
        is_required = data.required;
        type = data.type, name = data.name;
        value_info = this._get_value_info(elem, data);
        value = value_info.value, original_value = value_info.original_value, value_has_changed = value_info.value_has_changed, usedValFunc = value_info.usedValFunc;
        if (options.all === false && !is_required && (value.length === 0 || type === "radio" || type === "checkbox")) {
          if (data.error_targets == null) {
            data = this._cache_attribute(elem, data, "error_targets", function() {
              return this._get_error_targets(elem, type);
            });
            this._set_element_data(elem, data);
          }
          continue;
        }
        elem_errors = this._validate_element(elem, data, value_info, options);
        if (elem_errors.length > 0) {
          errors = errors.concat(elem_errors);
        }
      }
      grouped_errors = this._group_errors(errors, options);
      if (typeof this.process_errors === "function") {
        this.process_errors(grouped_errors);
      }
      if ((ref = this.form_modifier) != null) {
        ref.modify(grouped_errors, options);
      }
      return grouped_errors;
    };

    FormValidator.prototype.get_progress = function(options) {
      var all_optional, count, elem, error, errors, fields, found_error, group, groups, i, l, len, len1, len2, len3, m, o, q, required, total;
      if (options == null) {
        options = {
          as_percentage: false,
          recache: false
        };
      }
      if ((this.fields == null) || options.recache === true) {
        this.cache();
      }
      fields = this.fields.all;
      required = this.fields.required;
      groups = (typeof this.group === "function" ? this.group(fields) : void 0) || this._group(fields);
      total = groups.length;
      count = 0;
      errors = this.validate({
        apply_error_classes: false,
        all: true
      });
      for (i = l = 0, len = groups.length; l < len; i = ++l) {
        group = groups[i];
        all_optional = true;
        for (m = 0, len1 = group.length; m < len1; m++) {
          elem = group[m];
          elem = $(elem);
          if (required.index(elem) >= 0) {
            all_optional = false;
            break;
          }
        }
        found_error = false;
        for (o = 0, len2 = group.length; o < len2; o++) {
          elem = group[o];
          elem = $(elem);
          for (q = 0, len3 = errors.length; q < len3; q++) {
            error = errors[q];
            if (!(error.element.is(elem))) {
              continue;
            }
            found_error = true;
            break;
          }
          if (found_error) {
            break;
          }
        }
        if (!found_error) {
          count++;
        }
      }
      if (!options.as_percentage) {
        return {
          count: count,
          total: total
        };
      }
      return count / total;
    };

    return FormValidator;

  })();

  $(document).ready(function() {
    $(document).on("click", "[data-fv-start]", function() {
      var $elem, container, error, error1, error2, form_validator, options;
      $elem = $(this);
      if ((container = $elem.data("_form_validator_container")) == null) {
        container = $elem.closest($elem.attr("data-fv-start"));
        if (container.length === 0) {
          container = $($elem.attr("data-fv-start"));
        }
        $elem.data("_form_validator_container", container);
      }
      if (DEBUG && container.length === 0) {
        throw new Error("FormValidator (in validation on click triggered by 'data-fv-start'): No container found. Check the value of the 'data-fv-start' attribute (so it matches a closest element or any element in the document)!");
      }
      if ((form_validator = container.data("_form_validator")) == null) {
        options = $elem.attr("data-fv-start-options");
        if (options != null) {
          try {
            options = JSON.parse(options);
          } catch (error1) {
            error = error1;
            try {
              options = window[options]();
            } catch (error2) {
              error = error2;
              options = {};
            }
          }
        }
        form_validator = FormValidator["new"](container, options);
        container.data("_form_validator", form_validator);
      }
      form_validator.validate();
      return false;
    });
    $(document).on("change keyup", "[data-fv-real-time] [data-fv-validate]", function(evt) {
      var $elem, container, form_validator, is_textfield, ref, type;
      $elem = $(this);
      type = ((ref = $elem.attr("type")) != null ? ref.toLowerCase() : void 0) || "";
      is_textfield = $elem.filter("textarea").length === 1 || $elem.filter("input").length && (type === "button" || type === "checkbox" || type === "color" || type === "file" || type === "image" || type === "radio" || type === "range" || type === "submit");
      if (evt.type === "change" && is_textfield) {
        return true;
      }
      container = $elem.closest("[data-fv-real-time]");
      if (container.length === 1) {
        if ((form_validator = container.data("_form_validator")) == null) {
          form_validator = FormValidator["new"](container);
          container.data("_form_validator", form_validator);
        }
        if (DEBUG) {
          console.log(form_validator.validate({
            focus_invalid: false
          }));
        } else {
          form_validator.validate({
            focus_invalid: false
          });
        }
      }
      return false;
    });
    return true;
  });

}).call(this);
